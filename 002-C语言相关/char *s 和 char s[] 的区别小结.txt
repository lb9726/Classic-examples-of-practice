char *s 和 char s[] 的区别小结

博客分类： C语言
c教育 
最近的项目中有不少c的程序，在与项目新成员的交流中发现，普遍对于char *s1 和 char s2[] 认识有误区（认为无区别），导致有时出现“难以理解”的错误。一时也不能说得很明白，网上也搜了一下相关文章发现一些写的比较好的，综合了一下当教育资料备用。
 
char *s1 = "hello";
char s2[] = "hello";
 
【区别所在】
char *s1 的s1，而指针是指向一块内存区域，它指向的内存区域的大小可以随时改变，而且当指针指向常量字符串时，它的内容是不可以被修改的，否则在运行时会报错。
char s2[]的s2 是数组对应着一块内存区域，其地址和容量在生命期里不会改变，只有数组的内容可以改变
 
【内存模型】
       +-----+     +---+---+---+---+---+---+
   s1: |  *======> | h | e | l | l | o |\0 |
       +-----+     +---+---+---+---+---+---+
       +---+---+---+---+---+---+
   s2: | h | e | l | l | o |\0 |
       +---+---+---+---+---+---+
 
场景一）
char *s1 = "hello";
char s2[] = "hello";
s2=s1;  //编译ERROR
s1=s2;  //OK
 
分析：s2其地址和容量在生命期里不能改变
 
场景二）
char s2[] = "hello";
char *s1 = s2;  //编译器做了隐式的转换 实际为&s2
或
char *s1 = &s2;
 
分析：以上两个指针复值完全等价，由于编译器会做这个隐式转换也容易导致初学者误认为 char *s 与char s[]是一回事。
      另用第二种在一些编译器甚至会报警告信息。
 
场景三）
char *s1 = "hello";
char s2[] = "hello";
s1[0]='a';  //×运行ERROR（ 这一句好像在一些的编译器不会出错，原因待查）
s2[0]='a';  //OK
 
分析：运行时会报错，原因在于企图改变s1的内容，由于s1指向的是常量字符串，其内容是不可修改的，因此在运行时不会通过。而s2指向的是变量区字符串，可以修改。
 
场景四）
让我们来给一个指针的指针赋值，在使用某些含char**参数的函数时会用到，场景二的增强版。
    char *s1="hello";
    char s2[]="hello";
    char *s3=s2;       //★注意这句必须要★
    char **s4=&s3;   //s2（char[]）要用两步才能完成赋值
    char **s5=&s1;   //s1（char*） 只需一步
    printf("s4=[%s]\n",*s4);//打印结果：s4=[hello]
    printf("s5=[%s]\n",*s5);//打印结果：s5=[hello]
 
分析：这个例子应当说最能反映出char *与char []的差异，但是由于使用场合不多，新人尤其需要注意。
 
下面是一些char *s1 和 char s2[]相同的地方（同样编译器对char[]做了隐式变化）：
1)作为形参完全相同
如：
   void function(char *s1);
   void function(char s1[]);
 
2)只读取不修改的时候
如：
    char *s1="hello";
    char s2[]="hello";
    printf("s1[1]=[%c]\n",s1[1]);   //s1[1]=[e]  
    printf("s2[1]=[%c]\n",s2[1]);   //s2[1]=[e] 
    printf("s1=[%s]\n",s1);         //s1=[hello]
    printf("s2=[%s]\n",s2);         //s2=[hello]
