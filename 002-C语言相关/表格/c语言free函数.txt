
1、free(str) //释放str所指向的空间----告诉系统，这个空间可以被重新分配了。此时str本身的值（即所指向的空间不变），所以为了保证指针的安全性，通常都会在free(str);之后紧跟一句str=NULL,避免str再次操作到原来的空间。
2、在str指向的空间释放给系统之后，原来空间的内容并没有被立即清除掉。但一旦系统将这块空间重新分配给别的变量之后，一旦有变量赋值操作，该空间内的值就会变成新的变量的值。（这也是为什么要进行str=NULL操作，就是为了避免原来的指针str操作新的变量）。

您好，楼上说的不准确，也不是很完整。
关于用malloc分配的内存，在调用free释放后，该内存的状态，有以下几点说明：
1.调用free释放掉所分配的内存后，表明该内存可以被别人使用，也就是说，其他地方调用malloc后，可以分配到该内存
2.关于free释放该内存后，该内存中的数据，我们只能认为是脏数据；也就是说，这部分数据可能存在并且维持原来的值，也可能被清空，或者被修改为其他值；
由此可见，有很多中可能情况，所以，在释放了该内存后，除了要对当时分配的指针赋值为NULL，还要注意不要再去引用这部分内存，不要尝试获取这部分的值，这些已经非法。
追问：
如果要是不在用这部分内存的话，那不就等于内存泄露了吗？释放和不释放这部分内存有什么区别呢？
追答：
释放了，不管后面用不用，都不算是泄漏；
如果没释放，却把之前分配空间时候得到的指针给赋值为NULL了，就是泄漏了；
释放了，别人就可以用，但是不一定非要用；不释放，别人一定用不了；
追问：
如果释放了为什么不能去引用这部分内存呢？如果引用了会怎么样呢？
追答：
上面已经说的很清楚了。
如果释放了，那么这部分的值有几种可能
1，还是原来的值
2，被清空为0，取决于平台和编译器的处理
3，被别人分配去了，已经修改了值

这里所说的：不能去引用，并不是说真的不允许，而是说：我们不应该去引用
如果引用了会如何：那不一定，看编译器的心情了

我给你举个实际的例子吧，比如说，老人告诉你，山里有蛇，不要上山。
这并不是说你上山了，就一定被蛇咬到，而是告诉你，有这种可能。至于你是否非要上，就看你了。
追问：
谢谢您，您说的这些我差不多明白了，但是还有一点有点迷糊，就是引用了这段内存的话，里边的值被修改了，那申请的这段内存所操作的数据就可能变了，对这段内存多所做的程序不就白做了吗？
追答：
我不太明白你说的引用了这段内存，是指释放前还是释放后。
如果说是在释放前，
A1、理论上只有分配的人才有这片内存的指针，才能进行修改这部分的值；如果确实是由分配的人修改的值，那就不算是白做了，因为他具有修改的权限；
A2、如果是被别人修改了，那确实会出问题，属于别人越界处理；
如果实在释放后，
B1、如果没有人再次分配了这片内存，那至于值再被改动，那是不影响的，因为没人要用它
B2、如果有人分配而且改动了值，那就符合上面的A1的情况，属于正常




