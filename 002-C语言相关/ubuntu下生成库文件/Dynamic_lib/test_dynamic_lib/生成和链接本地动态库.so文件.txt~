1 库的分类
根据链接时期的不同，库又有静态库和动态库之分。
静态库是在链接阶段被链接的（好像是废话，但事实就是这样），所以生成的可执行文件就不受库的影响了，即使库被删除了，程序依然可以成功运行。
有别于静态库，动态库的链接是在程序执行的时候被链接的。所以，即使程序编译完，库仍须保留在系统上，以供程序运行时调用。（TODO：链接动态库时链接阶段到底做了什么）

2 静态库和动态库的比较
链接静态库其实从某种意义上来说也是一种粘贴复制，只不过它操作的对象是目标代码而不是源码而已。因为静态库被链接后库就直接嵌入可执行文件中了，这样就带来了两个问题。
首先就是系统空间被浪费了。这是显而易见的，想象一下，如果多个程序链接了同一个库，则每一个生成的可执行文件就都会有一个库的副本，必然会浪费系统空间。
再者，人非圣贤，即使是精心调试的库，也难免会有错。一旦发现了库中有bug，挽救起来就比较麻烦了。必须一一把链接该库的程序找出来，然后重新编译。
而动态库的出现正弥补了静态库的以上弊端。因为动态库是在程序运行时被链接的，所以磁盘上只须保留一份副本，因此节约了磁盘空间。如果发现了bug或要升级也很简单，只要用新的库把原来的替换掉就行了。

那么，是不是静态库就一无是处了呢？
答曰：非也非也。不是有句话么：存在即是合理。静态库既然没有湮没在滔滔的历史长河中，就必然有它的用武之地。想象一下这样的情况：如果你用libpcap库编了一个程序，要给被人运行，而他的系统上没有装pcap库，该怎么解决呢？最简单的办法就是编译该程序时把所有要链接的库都链接它们的静态库，这样，就可以在别人的系统上直接运行该程序了。

所谓有得必有失，正因为动态库在程序运行时被链接，故程序的运行速度和链接静态库的版本相比必然会打折扣。然而瑕不掩瑜，动态库的不足相对于它带来的好处在现今硬件下简直是微不足道的，所以链接程序在链接时一般是优先链接动态库的，除非用-static参数指定链接静态库。



一： 生成.so动态库文件
方法一：
1.编译生成动态.so的库文件，再提供给别人使用时需要提供头文件和编译生成的库文件也就是.so文件
gcc -shared -fPIC formatPrintf.c -o libformatPrintf.so  可以一步生成.so文件，可以在当前路径下看到
多出来了一个库文件libformatPrintf.so文件


方法二：
也可以第一步先生成.o 文件，在生成.so文件 
1. gcc -c -fPIC formatPrintf.c 生成了一个.o 文件   //这里一定要加上-fPIC选项，不然下一步编译失败
2. gcc -shared -fPIC -o libformatPrintf.so formatPrintf.o  这一步生成了一个.so文件
-fPIC：编译动态库所必须的，输出不依赖位置的代码

二：调用.so动态库文件
1. 提供相应的头文件出来，放到测试的main.c 文件的同级目录的include目录中，把libformatPrintf.so文件放到lib目录中
2. 在main.c 中包含这个头文件，#include "./include/formatPrintf.h"
3. 调用"formatPrintf.h" 中的任意的函数，实现相应的功能
4. 编译生成可执行程序： gcc main.c -o main -L. ./lib/libformatPrintf.so  或者gcc main.c ./lib/libformatPrintf.so -L. -o main
-L. 告诉编译器在当前目录中查找库文件 


此处写成-lformatPrint而不能写成-llibformatPrint
gcc main.c -o 3main -L. -lformatPrintf 虽然编译能通过但是运行时还是会出现以下错误
./3main: error while loading shared libraries: libformatPrintf.so: cannot open shared object file: No such file or directory
把文件拷贝到 /usr/lib/下之后运行没有问题
sudo cp -v libformatPrintf.so  /usr/lib/

 Linux动态链接库的默认搜索路径是/lib和/usr/lib，因此动态库被创建后，一般都复制到这两个目录下面，当程序执行时需要某动态库，并且改动态库还没有加载到内存中，则系统会自动到这两个默认的搜索路径中去查找相应的动态库文件，然后加载改文件到内存中，这样程序就可以使用该动态库中的函数以及该动态库中的其他资源了。在linux中，动态库的搜索路径除了默认的搜索路径外，还可以通过其他三种方法来指定，这里只介绍其中的一种：通过环境变量LD_LIBRARY_PATH指定动态库搜索路径。


两个有用的命令

 

 

file程序是用来判断文件类型的，在file命令下，所有文件都会原形毕露的。

顺便说一个技巧。有时在 windows下用浏览器下载tar.gz或tar.bz2文件，后缀名会变成奇怪的tar.tar，到Linux有些新手就不知怎么解压了。但 Linux下的文件类型并不受文件后缀名的影响，所以我们可以先用命令file xxx.tar.tar看一下文件类型，然后用tar加适当的参数解压。

另外，还可以借助程序ldd实用程序来判断。

ldd是用来打印目标程序（由命令行参数指定）所链接的所有动态库的信息的，如果目标程序没有链接动态库，则打印“not a dynamic executable”，ldd的用法请参考manpage。


