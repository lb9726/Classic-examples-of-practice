C++的友元类和友元函数实例

#include <math.h>
#include <iostream>
using namespace std;

class Point
{
public:
    Point(double xx, double yy)
    {
        x = xx;
        y = yy;
    }
    void Getxy();
    friend double Distance(Point &a, Point &b);// 类Point的友元函数
    friend class You;                          // 类Point的友元类
private:
    double x, y;
};


class You
{
public:
    double Multi(Point &a)
    {
        cout<<"a.x = "<<a.x<<"a.y = "<<a.y;
        return a.x * a.y + 1;
    }
};

void Point::Getxy()
{
    cout<<" ("<<x<<","<<y<<")"<<endl;
}

/*
 * 类Point的友元函数
 * 可以在类的外部使用类的对象，来引用x，y这两个private的私有变量
*/
double Distance(Point &a, Point &b)
{
    double dx = a.x - b.x;
    double dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
}

int main(void)
{
    Point p1(3.0, 4.0);
    Point p2(6.0, 8.0);
    p1.Getxy();
    p2.Getxy();

    // Distance是类Point的友元函数，不是成员函数
    double d = Distance(p1, p2);
    cout<<" Distance is "<<d<<endl;
    You you; /*友元类定义*/
    d = you.Multi(p1);
    cout<<" Math.Multi is "<<d<<endl;
    return 0;
}

为什么会有友元函数？

结合着类的特性和类中一般成员函数，我们可以这样理解：类具有封装和信息隐藏的特性。只有类的成员函数才能访问类的私有 成员，程序中的其他函数是无法访问私有成员的。非成员函数可以访问类中的公有成员，但是如果将数据成员都定义为公有的，这又破坏了隐藏的特性。另外，应该 看到在某些情况下，特别是在对某些成员函数多次调用时，由于参数传递，类型检查和安全性检查等都需要时间开销，而影响程序的运行效率。

 
为了解决上述问题，提出一种使用友元的方案。友元是一种定义在类外部的普通函数，但 它需要在类体内进行说明，为了与该类的成员函数加以区别，在说明时前面加以关键字friend。友元不是成员函数，但是它可以访问类中的私有成员。友元的 作用在于提高程序的运行效率，但是，它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。

友元函数的特点是能够访问类中的私有成员的非成员函数。友元函数从语法上看，它与普通函数一样，即在定义上和调用上与普通函数一样.


https://blog.csdn.net/qq_25800311/article/details/82390244

采用类的机制后实现了数据的隐藏与封装，类的数据成员一般定义为私有成员，成员函数一般定义为公有的，依此提供类与外界间的通信接口。但是，有时需要定义一些函数，这些函数不是类的一部分，但又需要频繁地访问类的数据成员，这时可以将这些函数定义为该函数的友元函数。除了友元函数外，还有友元类，两者统称为友元。友元的作用是提高了程序的运行效率（即减少了类型检查和安全性检查等都需要时间开销），但它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。


友元函数 ： 
       友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend，其格式如下：
       friend 类型 函数名(形式参数);

       友元函数的声明可以放在类的私有部分，也可以放在公有部分，它们是没有区别的，都说明是该类的一个友元函数。
       一个函数可以是多个类的友元函数，只需要在各个类中分别声明。
       友元函数的调用与一般函数的调用方式和原理一致。

友元类 ： 
       友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。       
       当希望一个类可以存取另一个类的私有成员时，可以将该类声明为另一类的友元类。定义友元类的语句格式如下：
       friend class 类名;
       其中：friend和class是关键字，类名必须是程序中的一个已定义过的类。

       例如，以下语句说明类B是类A的友元类：
       
        例如，以下语句说明类B是类A的友元类：
       class A
       {
              …
       public:
              friend class B;
              …
       };
       经过以上说明后，类B的所有成员函数都是类A的友元函数，能存取类A的私有成员和保护成员。

       使用友元类时注意：
             (1) 友元关系不能被继承。 
             (2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。
             (3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的声明
             
《windows环境多线程编程原理与应用》中解释：

　 如果将类的封装比喻成一堵墙的话，那么友元机制就像墙上了开了一个门，那些得

　 到允许的类或函数允许通过这个门访问一般的类或者函数无法访问的私有属性和方　　　

　 法。友元机制使类的封装性得到消弱，所以使用时一定要慎重。


友元类的说明

　　　将外界的某个类在本类别的定义中说明为友元，那么外界的类就成为本类的“朋　　

　　　友”，那个类就可以访问本类的私有数据了。

　　　class Merchant

      {

          private :

             int m_MyMoney;

             int m_MyRoom;

             … …

          Public:

             Friend class Lawyer;

             Int getmoney();

             … …

      };

      Class Lawyer

     {

        Private:

          … …

        Public:

         … …

     };

     只有你赋予某个类为你的友元时，那个类才有访问你的私有数据的权利。

　 说明一个函数为一个类的友元函数则该函数可以访问此类的私有数据和方法。
　 定义方法是在类的定义中，在函数名前加上关键字friend.

挑战30天C/C++》这样解释：

　 在说明什么是友元之前，我们先说明一下为什么需要友元与友元的缺点: 
通常对于普通函数来说,要访问类的保护成员是不可能的，如果想这么做那么必须把类的成员都生命成为public(共用的)，然而这做带来的问题遍是任何外部函数都可以毫无约束的访问它操作它，c++利用friend修饰符，可以让一些你设定的函数能够对这些保护数据进行操作，避免把类成员全部设置成public，最大限度的保护数据成员的安全。 
友元能够使得普通函数直接访问类的保护数据，避免了类成员函数的频繁调用，可以节约处理器开销，提高程序的效率，但所矛盾的是，即使是最大限度大保护，同样也破坏了类的封装特性，这即是友元的缺点，在现在cpu速度越来越快的今天我们并不推荐使用它，但它作为c++一个必要的知识点，一个完整的组成部分，我们还是需要讨论一下的。 
在类里声明一个普通数学，在前面加上friend修饰，那么这个函数就成了该类的友元，可以访问该类的一切成员。

   下面我们来看一段代码，看看我们是如何利用友元来访问类的一切成员的










