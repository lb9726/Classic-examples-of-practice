http://blog.csdn.net/shanzhizi/article/details/7835752

数组的动态分配(new)、初始化(memset)和撤销(delete)
 
一维数组的动态分配，初始化和撤销都好说，几乎每一本C++教材都会做出详细的说明。具体如下：
 
动态分配(例如分配n个单元的)： int *array=newint [n]；
 
初始化：memset(array,0,n*sizeof(array));       (也可以利用一个for循环对其赋值初始化)
 
撤销：delete [] array;
 
下面来说二维数组的。
 
二维数组(n行m列)利用new来进行动态分配实际上相当于对n个m元数组进行动态分配，只不过我们不能一味的按照动态分配一维数组的方法来进行这项操作。MSVC目前还没有这般的人性化，具体应该这样做：
 
int **array;
array=new int *[10];
for(int i=0;i<10;i++)
         array[i]=new int [5];
 
 
   上面的操作完成了一个10行5列的二维数组array[10][5]的动态分配,可以看到我们先动态分配了一个10单元的数组的指针的指针的首地址给**array，然后再对其每个首地址进行遍历，同时完成一个5单元的数组的动态分分配，并把首地址给*array[i]，从而最终完成了二维数组array[10][5]的动态分配。我们可以依此类推得到三维以至多维的数组的动态分配方法。
 
二维数组的初始化：如果把一维数组初始化办法照搬过来就会发现对于动态分配的二维数组并不适用。这就要理解到memset这个函数三个参数的含义。MSDNhttp://blog.csdn.net/shanzhizi对memset的描述如下：
 
memset
 
Sets buffers to a specified character.
 
void *memset( void *dest, int c, size_t count );
 
可见memset只能作用于一个一维数组void *dest，因此最好的办法就是和二维数组的动态分配结合起来，new一个，memset一个。
 
我的理解是memset只作用于一块连续的内存空间，而动态开辟的空间不一定是连续的，SO。
 
具体写法如下：
 
int **array;
array=new int *[10];
for(int i=0;i<10;i++)
{
         array[i]=new int [5];
        memset(array,0,5*sizeof(int));
}
 
可以看到这里的memset的第三个参数有了变化。
 
二维数组的撤销：
 
for (int i = 0; i < 10; i ++) {
     delete[] array[i];
}
delete [] array；
 
 
三维数组用一个例子说明：
 
#include <stdio.h>
#include <memory.h>
 
#define size1 5
#define size2 10
#define size3 15
 
int main()
{
       int *** arr;
       int i,j,k;
       /////////////////// 动态开辟 相当于arr[size1][size2][size3]
       arr = new int**[size1];
       for (i = 0; i < size1; i ++) {
              arr[i] = new int*[size2];
              for (j = 0; j < size2; j ++) {
                     arr[i][j] = new int[size3];
              }
       }
       /////////////////// 用for循环初始化
       for (i = 0; i < size1; i ++) {
              for (j = 0; j < size2; j ++) {
                     for (k = 0; k < size3; k ++) {
                            arr[i][j][k] = i * j * k;
                     }
              }
       }
       for (i = 0; i < size1; i ++) {
              for (j = 0; j < size2; j ++) {
                     for (k = 0; k < size3; k ++) {
                            printf("i*j*k=%d*%d*%d=%d/n",i,j,k,arr[i][j][k]);
                     }
              }
       }
       /////////////////// 用memset，如果是静态int arr[][][]的话，直接memset(arr,0,sizeof(arr));数组初始化为0
 
       for (i = 0; i < size1; i ++) {
              for (j = 0; j < size2; j ++) {
                     memset(arr[i][j],-1,sizeof(int) * size3);
              }
       }
 
       for (i = 0; i < size1; i ++) {
              for (j = 0; j < size2; j ++) {
                     for (k = 0; k < size3; k ++) {
                            printf("i,j,k=%d,%d,%d=%d/n",i,j,k,arr[i][j][k]);
                     }
              }
       }
 
       ///////////////////// 释放内存
       for (i = 0; i < size1; i ++) {
              for (j = 0; j < size2; j ++) {
                     delete[] arr[i][j];
              }
              delete[] arr[i];
       }
       delete[] arr;
       return 0;
}
http://blog.csdn.net/shanzhizi
