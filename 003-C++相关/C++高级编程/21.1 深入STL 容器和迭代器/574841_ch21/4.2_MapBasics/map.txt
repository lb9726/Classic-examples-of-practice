map是最有用的容器之一。它存储的是键/值对而不是一个值。插入，查找和删除都基于键完成，值只是顺带的。“映射”（map) 一词就源于其概念理解，即容器将键“映射”至值。你可能对散列表的概念更熟悉一些。映射也提供了一个类似的接口，只是在底层数据结构和操作的算法复杂性上存在区别。
 map会基于元素的键来保证元素有序，因此插入，删除和查找都取对数时间。通常map实现为某种形式的平衡树，如红黑树。不过，客户并不会看到这个树结构。
如果要基于一个“键”值来存储和获取元素，就应该使用map。


构造映射
   map模板取4个类型：键类型，值类型，比较类型和分配器类型。与以往一样，这一章先不谈分配器，有关的详细内容请见23章。比较类型类似于上述priority_queue 的比较类型。利用比较类型，可以指定一个与默认比较奥类不同的比较类。通常无需改变排序规则。在这一章中，我们只使用默认的less比较。使用默认比较类时，要确保键都适当地对应于operator<

如果对更多细节感兴趣，地22章解释了如何编写自己的比较类。
如果忽略了比较和分配器参数（在此就要求你这样做),构造map就与构造一个vector或list颇为相似，只不过要在模板中分别指定键和值类型。例如：以下代码会构造一个map，这个映射使用int作为键，并保存Data类的对象作为值

#include<map>
using namespace std;
class Data
{
public:
    Data(int val = 0) { mVal = val;}
    int getVal()const { return mVal;}
    void setVal(int val) { mVal = val;}
// Remainder of definition omitted
protected:
    int mVal;
};

int main(int argc, char **argv)
{
    map<int, Data> dataMap;
    return 0;
}
