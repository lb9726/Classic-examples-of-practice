多态性是面向对象程序设计的第三个重要机制。所谓多态性是指同样的消息被不同的类的对象接收时导致完全不同行为的这样的一种状态。
同一个消息作用于不同的对象，其结果各不相同，具有多种形态。这里的消息是指对对象成员函数的调用。

联编是指将函数调用与相应的函数代码彼此相关联的过程。如果联编在编译阶段完成，称之为静态联编。重载函数就是静态联编的方式。因为虽然两个函数具有相同的函数名，但由于其参数类型不同，编译程序可以据此来自动选择对应的函数体进行匹配，也就是说重载函数可以在编译时期确定调用哪个函数，因此称为静态联编。

在C++中还有一种联编方式称为动态联编。这种方式是在程序运行时进行联编，即当程序调用到某一函数名时，才去寻找和连接其程序代码，一般通过函数指针或引用来实现。

虚函数
虚函数存在于继承环境中。虚函数机制使得基类(父类)中定义虚函数后，派生类(子类)中可以重写基类(父类)中成员函数的代码，
从而使得在类层次结构中，同一个成员函数可以有不同的版本(即不同的代码)。此时，当一个基类类型的指针指向派生类对象时，若向指针所指的对象发消息，
则应该是派生类对象对应的代码被执行。但指针所指的对象可能只有执行时才能知道，这样到底执行哪些代码只有运行时才能根据指针所指的对象来决定，
因此虚函数采用动态联编的方式实现。

对虚函数，以下几点值得注意：
虚函数无论被继承多少次，仍是虚函数;若在派生类中对其重新定义，关键字virtual可写可不写，但函数的原型必须和基类的原型完全相同，
包括函数名，返回类型，参数个数和参数类型的顺序。此时无论在派生类中的相应函数前是否加有关键字virtual，都将视其为虚函数。
如果只是函数名相同，而函数原型不同，则C++会看作函数重载，而不是虚函数。
静态成员函数，构造函数和友元函数都不能被声明为虚函数，因为它们依赖于对象。此外，全局函数和内联函数也不能声明为虚函数。
一般只将protected和public部分的成员函数声明为虚函数。
析构函数可以是虚函数。如果基类声明了虚析构函数，则为派生类自动生成的析构函数是虚析构函数。当撤销一个派生类对象时，
会由最底层派生类的析构函数开始调用，并依派生类继承的逆序逐一调用直至最顶层基类。只有通过基类指针或引用访问基类的虚函数是，才能获得运行时的多态。
若虚函数在派生类中未被重定义，则通过派生类对象访问该虚函数时将使用基类中定义的同名虚函数。
虚函数可以另一个类的友元函数。

在继承时，派生类继承了基类所有数据成员的副本。在多重继承时，如果基类又有共同的基类，则派生类中存在成员相重现象而导致冲突。
为了解决这种冲突，C++中只需将这个共同的基类说明为虚基类即可。所谓虚基类是指这样的基类：它虽然被一个派生类间接地多次继承，
但是派生类只继承该基类成员的一个拷贝。这样，就避免了在派生类中访问这些成员时产生成员冲突的现象。

在定义类时，将一个基类声明为虚基类的方法是在各派生类定义时，在基类的名称前加上关键字virtual,格式为：
class 派生类名: virtual public 基类名
{
    声明派生类成员
};

注意：如果虚基类存在带参数的构造函数，则在其所有的派生类(无论是间接还是直接的)都必须定义构造函数对虚基类进行初始化。
基类构造函数的调用顺序为：先按声明的先后顺序调用那个虚基类的构造函数，再按声明的先后顺序调用一般基类的构造函数。


纯虚函数和抽象类
在访问基类虚函数时，若不通过基类指针或引用来访问基类的虚函数，则不能实现多态性。如将func(BASE& obj)定义改为：
void func(BASE obj)
{
    obj.Inc();
    obj.display();
}

则只能调用基类中成员函数Inc() 与 display()，尽管它们在基类中声明为虚函数。为了防止这种情况的发生，C++提供了
一种称为 纯虚函数 的机制。在基类只声明虚函数，而不给出具体的函数定义，将函数定义放在各派生类中，称这种虚函数为
纯虚函数
声明纯虚函数的形式为：
    virtual 函数返回值类型函数名(参数表):0;
    或virtual 函数返回值类型函数名(参数表):0
    {
        函数体
    }
    
    其中，virtual关键字与函数返回值类型的位置可以互换。
    声明纯虚函数的类为抽象类。抽象类在现实中对应的只是一个概念，并不与具体的事物联系。比如”几何图形“类就是一个抽象类，
    要在几何形状 类中定义一个求面积的函数显然是无意义的。抽象类作为基类只是用于继承，主要用来为它的派生类提供相同的接口
    和代码，各派生类将根据不同的情况来对虚函数进行重新定义，具体功能在派生类中实现。通过该基类的指针或引用，可以调用所有派生类的需函数。
    
    注意：
    抽象类只能作为其他类的基类，不能用来建立该类的对象，但可以声明指向抽象类的指针变量和引用变量
    纯虚函数中定义的代码在派生类中可以通过作用域运算符(::)来调用它。
    抽象类不能用作参数类型，函数返回值类型或显示转换的类型，但可以用作指针或引用的类型。
    抽象类的派生类中若对 纯虚函数 没有重新定义，则这个派生类仍还是一个抽象类
    抽象类可以有多个纯虚函数。
    













