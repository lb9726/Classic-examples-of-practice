2.2 套接字的类型
套接字支持各种通信协议，目前linux 系统常用的协议有以下两种：
(1) INET:IP版本4
(2) INET6：IP版本6

套接字类型是指创建套接字的应用程序要使用的通信服务类型。Linux系统支持多种套接字类型，最常用的有以下几种：
(1) SOCK_STREAM:流式套接字，提供面向连接，可靠的数据传输服务，数据按字节流，按顺序收发，保证数据在传输过程中无丢失，无冗余。TCP协议支持该套接字。
(2) SOCK_DGRAM:数据报套接字，提供面向无连接的服务，数据收发无序，不能保证数据的准确到达。UDP协议支持该套接字。
(3) SOCK_RAW:原始套接字。允许对低于传输层的协议或物理网络直接访问，例如可以接收和发送ICMP报。常用于检测新的协议。


2.3 套接字地址结构
在使用套接字函数编写网络程序时，大多数函数都需要一个指向地址结构的参数。每个协议族都定义了自己的套接字地址结构，这些结构的名字均以sockaddr_开始，并以对应每个协议族为后缀。例如：IPv4的套接字地址结构为sockaddr_in, 而IPv6 的套接字地址结构为sockaddr_in6。

2.3.1 IPv4套接字地址结构
IPv4套接字地址结构通常也称为“网际套接字地址结构",它的的名字为sockaddr_in，定义在头文件<netinet/in.h>中，其结构定义如下：
typedef uint32_t in_addr_t;
typedef uint16_t in_port_t;
typedef unsigned short sa_family_t;

struct in_addr 
{
    in_addr_t s_addr;
};

struct sockaddr_in
{
    uint8_t         sin_len;
    sa_family_t     sin_family;
    in_port_t       sin_port;  // 端口号
    struct in_addr  sin_addr;  // IP
    char            sin_zero[8];
};

在sockaddr_in 结构体中包含5个成员，需要注意的是，其中sin_addr 成员的类型是结构体，
它存储的是存放IP地址的结构体名称。各成员的作用如下：
1. sin_len 是长度成员，存储套接字地址结构的长度，但不是所有系统都支持，有了它可以简化变长套接字地址结构的处理。
一般情况下不需要设置它和检查它，除非涉及到路由套接字。
2.sin_family 是Internet地址族，在IPv4中是AF_INET。
3. sin_port 是端口号，以网络字节序存储。
4. sin_addr 是一个结构，该结构中的成员存储的才是Ip地址。
5. sin_zero 成员暂时没有使用，但总是将它置为0。所以为了方便，在初始化结构时，将整个结构置为0。
6. in_addr结构中的s_addr成员存储的是网络字节序的32位IPv4地址。
通过给出IPv4套接字地址结构发现，可以有两种不同的方式来访问IP地址。例如：struct sockaddr_in ser;
则ser.sin_addr 给出的是一个存放地址的in_addr 结构;而ser.sin_addr.s_addr 存储的是地址中的内容，
也就是IP地址的值。因此在IP地址作为参数传递时，一定要注意，传递结构和传递整数编译器的处理是完全不同的。


IPv6套接字地址结构
IPv6 套接字地址结构的名字为sockaddr_in6,定义在头文件<netinet/in.h>中，其结构定义如下：
 typedef uint16_t in_port_t;
 typedef unsigned short sa_family_t;
 
 struct in6_addr
 {
    uint8_t s6_addr[16];
 };
 
 struct sockaddr_in6
 {
    uint8_t sin6_len;
    sa_family_t sin6_family;
    in_port_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
 };
 
 sockaddr_in6结构的构成与sockaddr_in 基本相同，各成员的作用如下：
 1. sin6_len 是长度成员，如果系统支持套接字地址结构中的长度成员，则SIN6_LEN 常值必须定义。
 2. sin6_family 是internet地址族，在IPv6中是AF_INET6。
 3. sin6_port 是端口号，以网络字节序存储。
 4. sin6_flowinfo 成员分为3个字段：
    1.低24位是流量标号
    2.下4位是优先级
    3.再下4位保留
 5. sin6_addr是一个结构，该结构中的成员存储的才是IP地址。IPv6地址长度为128位。
 6. in6_addr 结构中的s6_addr成员，存储的是网络字节序的128位IPv6地址。
 
 
 2.3.4 通用套接字地址结构
 套接字地址结构作为参数传递给任一个套接字函数时，通常通过指针来传递。当套接字函数取得此参数时，参数中可能存放的是来自
 所支持的任何协议族的地址结构。因此在调用套接字函数时，需要将指向特定于协议的地址结构的指针类型转换成指向通用地址的指针。
 通用套接字地址结构定义在头文件<sys/socket.h> 中。具体的结构定义如下：
 struct sockaddr
 {
    uint8_t sa_len;
    sa_family_t sa_family;
    char sa_data[14];
 };

许多套接字函数使用该通用的地址结构作为参数。例如：
struct sockaddr_in ser;
bind(sockfd, (struct sockaddr *)&ser, sizeof(ser));
如果省略了其中的强制类型转换(struct sockaddr *)&ser，系统通常会产生这样的警告信息：将不兼容的指针类型传递给bind函数



2.4 套接字的基本函数
2.4.1 字节排序函数
 内存中存储字节有两种不同的方法，不同系统采用的存储方式可能不同，为了使得不同主机能够相互通信，必须定义一个存储数据的标准。
 字节存储的顺序分为以下两类：
 1. 小端字节序：将低序字节存储在起始地址
 2. 大端字节序：将高序字节存储在起始地址
 
 <-------------------------------------
 小端字节序   高序字节          低序字节
               
 网络字节序 MSB最高有效位16位值   LSB
 
 ------------------------------------>
 大端字节序   高序字节         低序字节

将某给定主机所使用的字节序主机字节序（Host Byte Order)。为了使采用不同字节序的主机能够相互通信，TCP/IP协议
规定了网络字节序。所有主机或路由器在发送IP数据包之前要首先将相应的信息转换为网络字节序：相应地，在接收数据包后，
要将网络字节序转换成主机字节序。因此，无论主机系统采用的是何种字节序，它们之间都可以正常通信。

主机字节序和网络字节序之间的相互转换，要用到一下4个函数
#include<netinet/in.h>
uint16_t htons(uint16_t hosts);
uint32_t htonl(uint32_t hostl);
uint16_t ntohs(uint16_t nets);
uint32_t ntohl(uint32_t netl);

1.htons: 将16位短整形数从主机字节序转换成网络字节序
2.htonl: 将32位长整形数从主机字节序转换成网络字节序
3.ntohs: 将16位短整形数从网络字节序转换成主机字节序
4.ntohl: 将32位长整形数从网络字节序转换成主机字节序

上述的4个函数中：h代表主机host，n代表网络network，s代表短整形short，l代表长整形long。
当使用以上函数时，不必关心主机字节序和网络字节序的真实值，只是适当的函数对给定值进行主机
字节序与网络字节序之间的转换即可。如果当前主机字节序和网络字节序的存储字节顺序相同，这4个函数通常被定义成空宏。


2.4.2 字节操纵函数
当使用套接字地址结构时，其中的IP地址字段包含多少个字节的0,但又不是c字符串，对这样的字段进行操作时需要用到字节
操纵函数。下面介绍两组操纵函数，第一组函数名字以字母b（byte）开头，起源于4.2BSD;第二组函数名字一mem（memory）
开头，起源于ANSIC标准。
 #include<string.h>
 void bzero(void *dest, size_t len);
 void bcopy(const void *src, void *dest, size_t len);
 void bcmp(const void *src, void *dest, size_t len);
 
 bzero函数将目标中指定数目的字节置为0,经常用此函数来对套接字地址结构进行初始化，bcopy函数将指定数目的字节从源
 拷贝到目标bcmp函数比较源和目标两个字符串，若相同返回值为0,否则返回非0值。
 下面的函数是ANSIC函数：
 void *memset(void *dest, int x, size_t len);
 void *memcpy(void *dest, const void *src, size_t len);
 void *memcmp(const void *str1, const *str2, size_t len);
 
 memset函数将目标指定数目的字节置为值x; bcopy与memcpy函数类似，但交换了源和目标指针参数的位置，当源与目标重叠时，bcopy函数能
 正确处理，而memcpy函数的操作结果则是不可知的; memcmp函数比较两个字符串，若相同返回值为0, 否则返回非0值，如果str1所指字节大于
 str2所指字节，则返回值大于0,否则返回值小于0。
 
 
 2.4.3 IP地址转换函数
 通常人们比较喜欢用点分十进制来表示IP地址，而套接字地址结构中却需要用网络字节序的二进制存储。为方便字符串的IP和二进制值的IP相互
 转换，Linux系统提供了相应的地址转换函数。
 
 #include<arpa/inet.h>
 in_addr_t inet_addrconst char *str);
 int inet_aton(const char *str, struct in_addr *numstr);
 char *inet_ntoa(struct in_addr inaddr);
 
 函数中a代表ASCII串;n代表数值（numeric）格式，是存在于套接字地址结构中的二进制值。
 1. inet_addr 函数。将字符串形式的IP地址转换为32位二进制值的IP地址。str指向字符串形式的IP地址。
 函数调用成功，返回值为32位字节序的二进制的IP地址。这个函数不对IP地址的有效性进行验证，所有2的32次方个
 （0.0.0.0 ～ 255.255.255.255）可能的二进制值都认为是有效的IP地址。由于该函数会返回一个常值INADDR_NONE(一般为一个32位均为1的值），
 所以对于点分十进制的IP地址255.255.255.255不能由此函数处理。现在人们常用inet_aton 函数代替inet_addr函数。
 
 2.inet_aton 函数。进行相同的转换。str指向字符串形式的IP地址。numstr指向转换后的32位网络字节序的IP地址。如果成功返回1,否则返回0
 
 3.inet_ntoa 函数。 将一个32位网络字节序的二进制IP地址转换成相应的点分十进制的IP地址。这个函数的参数是一个
 结构，而不是指向结构的指针。该函数的返回值所指向的串留在静态内存中，所以函数是不可重入的。
 
 上述的3个地址转换函数都只能处理IPv4的地址，而不能处理IPv6地址。下面介绍两个较新的函数，它们对IPv4和IPv6地址都能处理
 #include<arpa/inet.h>
 int inet_pton(int family, const char *str, void *numstr);
 const char *inet_ntop(int family, const void *numstr, char *str, size_t len);
 
 函数中p代表地址的表达式（presentation），格式通常是ASCII串;n 代表数值（numeric）格式，是存在于套接字地址结构中的二进制值。
 这两个函数中的family参数指的是操作地址的地址族，IPv4是AF_INET，而IPv6是AF_INET6

1. inet_pton函数。将指针str所指的字符串形式的IP地址转换为网络字节序的二进制IP地址，并用指针numstr存储。如果成功返回1,
如果指定的family输入字符串不是一个有效的表达格式，则返回值为0,出错返回-1。

2. inet_ntop 函数。进行相反的操作，将numstr所指的二进制IP地址转换成字符串形式的IP地址，并用指针str存储。参数len是目标的大小
，为了避免函数溢出其调用者的缓冲区，如果len太小无法容纳表达式的结果，则返回一个空指针，并置errno为ENOSPC。由于参数str不能是
空指针，调用者必须为目标分配内存并指定大小，成功时，此指针就是函数的返回值。









