守护进程是在后台运行不受终端控制的进程。 unix系统中有很多守护进程在后台运行，执行不同的管理任务。
在网络应用方面，许多服务器都是以守护进程的方式运行的。创建守护进程的方法是使进程不拥有终端，这使得
守护进程不能fprintf和stderr上，而必须使用其他的方法来登记消息，通常调用syslog函数。inetid超级服务器
本身就是一个守护进程，但它能够处理许多其他的服务，基于UDP和TCP的服务器都可以使用inetd超级服务器，使得
这些服务器的创建和管理较为方便。

守护进程是在后台运行不受终端控制的进程(如输入，输出等)，一般的网络服务都是以守护进程的方式运行。守护进程
脱离终端的主要原因有以下亮点：
1. 用来启动守护进程的终端在启动守护进程之后，需要执行其他任务。例如其他用户登录该终端后，以前的守护进程
的错误信息不应出现。
2. 由终端上的一些键所产生的信号(如中断信号) 不应对以前从该终端上启动的任何守护进程造成影响。
注意：守护进程和后台运行程序是有区别的。加&启动的程序是后台运行的程序，虽然运行时与守护进程相似，
但它拥有控制终端。


8.1.1 启动守护进程
启动守护进程的方法有很多种
在系统启动时很多守护进程都是由系统初始化脚本启动的。这些脚本一般在/etc目录或者以/etc/rc开头的目录下，
它们的位置和内容依赖于具体的实现。由这些脚本启动的守护进程在开始时拥有超级用户权限。
    有几个网络服务器一般从这些脚本启动：inetd超级服务器，web服务器和邮件服务器(一般为sendmail)，syslogd
    守护进程通常也是由某个这个的脚本启动的。
    许多网络服务器是由inetd超级服务器启动的。inetd自己是由系统初始化脚本启动的。inetd监听网络请求(Telnet, FTP等)，
    当请求到来时启动实际的服务器(Telnet服务器，FTP服务器等)。
    
    cron守护进程按规则定期执行一些脚本程序，由他启动的程序也以守护进程的方式运行。cron也是由系统初始化脚本启动的。
    
    可以用at命令指定在将来的某一时刻执行程序。cron守护进程在到达相应的时间会启动这些程序，所以它们是以守护程序的方式运行的。
    
    不管是在前台还是后台，守护进程也可以在用户终端上启动。在编写一个守护进程程序后，通常通过这种方式测试程序。
    
    
 8.1.2 输出守护进程消息
    由于守护进程没有控制终端，而发生问题时它要用一些其他方式输出消息。这些消息既有一般通告消息，也有需要管理员处理的
    紧急事件消息。syslog函数是输出这些消息的标准方式，它将消息发往syslogd守护进程。syslogd守护进程再将消息作进一步处理。
    当然也可以通过向文件中写数据来输出消息，但这样不好管理，因为每一个守护进程要对应一个文件。
    syslogd是一个系统守护进程，它主要负责接收系统和用户守护进程的输出消息，并根据配置信息作出相应的处理。
    syslogd守护进程在启动时执行以下操作：
    1. 读入配置文件，通常是/etc/syslog.conf,它设定守护进程对接收每次键入的各种登记消息怎样处理。这些消息可能被写入一个文件
    (控制台是名为/dev/console的特殊文本)，或发给指定的用户，或转发给另一台主机的syslogd进程。
    2. 创建一个unix域套接口，捆绑路径名/var/run/log(在某些系统上是/dev/log)。
    3. 创建一个UDP套接口，捆绑端口514(syslog服务使用的端口号)。
    4. 打开路径名/dev/klog，内核中的所有出错消息作为这个设备的输入出现。
    在这之后syslogd进程运行一个无限循环，循环中调用select，等待3个描述字(以上第2,3,4步生成的描述字)之一变为可读，
    读入登记消息，并按配置文件对消息进行处理，如果该守护进程收到SIGHUP信号，他会重新读入配置文件。
    所以在守护进程中，可以通过建立一个UNIX域数据包套接口，并向syslogd守护进程绑定的路径名发送消息，就能向syslogd
    发送登记消息。也可以创建一个UDP套接口，将日志消息发到回馈地址及端口514.但更简单的方式是使用syslog函数。
    在新的实现中除非管理员指定，并不创建UDP套接口，这是因为允许任何人向这个端口发送UDP数据报(有可能填满它的套接口缓冲区)
    可能导致收不到真正需要处理的登记消息。
    
    
    8.1.3 syslog函数
    #include <syslog.h>
    void syslog(int priority, const char * message, ...);
    参数message与printf所用的格式化字符串类似，同时增加了%m，他将由对应的当前errno值的出错消息所取代。
    参数priority是级别(level)和设施(facility)的组合。设施和级别的目的是允许在/etc/syslog.conf文件中进行配置，
    使得对相同设施的消息得到同样的处理，或使相同级别的消息得到同样的处理。等级消息的级别和设施分别如下：
    
    等级消息的级别
    级别(level)              值             描述
    LOG_EMERG                0            系统不可用(优先级最高)
    LOG_ALERT                1            必须立即进行处理
    LOG_CRIT                 2            危险情况
    LOG_ERR                  3            出错情况
    LOG_WARNING              4            警告情况
    LOG_NOTICe               5            常见但值得注意的情况(默认)
    LOG_INFO                 6            通告消息
    LOG_DEBUG                7            调试消息(优先级最低)
    
    等级消息的设施
    设施(facility)             描述
    LOG_AUTH                 安全/授权消息
    LOG_AUTHPRIV             安全/授权消息(私有)
    LOG_CRON                 cron守护进程
    LOG_DAEMON               系统守护进程
    LOG_FTP                  FTP守护进程
    LOG_LOCAL0               本地使用
    LOG_LOCAL1               本地使用
    LOG_LOCAL2               本地使用
    LOG_LOCAL3               本地使用
    LOG_LOCAL4               本地使用
    LOG_LOCAL5               本地使用
    LOG_LOCAL6               本地使用
    LOG_LOCAL7               本地使用
    LOG_LPR                  行式打印机系统
    LOG_MAIL                 邮件系统
    LOG_NEWS                 网络新闻系统
    LOG_SYSLOG               syslogd内部消息
    LOG_USER                 任意的用户消息(默认)
    LOG_UUCP                 UUCP消息
    
    
    下面举一个syslog函数的例子：当调用rename函数失败时，守护进程可能会调用
    if (rename(file1, file2) == -1)
    {   
        syslog(LOG_INFO | LOG_LOCAL2, "rename(%s, %s): %m", file1, file2);
    }
    如果配置文件/etc/syslog.conf中有以下几行：
    kern *               /dev/console
    local2.debug         /var/log/cisco.log
    local2.info          /var/log/test.log
    则指定内核的所有消息登记到控制台上，所有设施为local2的调试信息将添加到/var/log/cisco文件的末尾，
    所有设施为local2的通告信息将添加到/var/log/test.log文件的末尾。
    当应用程序第一次调用syslog时，它创建了一个UNIX域数据报套接口，然后添加connect连至syslog守护进程
    建立的套接口路径名(譬如/var/run/log)。这个套接口在进程终止前一直打开。另外，进程也可以调用openlog和closelog。
    void openlog(const char *ident, int option, int facility);
    void closelog(void);
    
    openlog 函数在第一次调用syslog函数之前调用，当不再需要发送登记消息时可以调用closelog函数。
    ident是一个字符串，它将被加到每条登记消息前面;option参数组合而成，facility参数为后面没有设置设施的syslog调用一个默认值
    
    选项option             描述
    LOG_CONS               如果不能发往syslog守护进程，则登记到控制台上
    LOG_NDELAY             不延迟打开，立即创建接口
    LOG_PERROR             既发往syslog守护进程，又登记到标准错误输出
    LOG_PID                登记每条消息的进程ID
    
    通常调用openlog时并不创建UNIX套接口，它是在第一次调用时打开的。LOG_NDELAY选项能使套接口在调用openlog时创建
    openlog的facility参数为后面没有设置syslog调用设置一个默认值。一些守护进程调用openlog设置设施，而在调用syslog时只设置级别。
    
    下面是一个使用syslog函数的简单例子：
    #include <syslog.h>
    #include <unistd.h>
    int main()
    {
        openlog("here", LOG_PID, LOG_USER);
        syslog(LOG_INFO|LOG_LOCAL2, "OK");
        closelog();        
    }
    注意： 如果syslog.conf文件中增加新行，需要重新启动syslog服务，方法是：/etc/rc.d/init.d/syslog restart。
    在上例中，syslog函数将"OK"字符串写入由syslog.conf配置文件指定的文件中，syslog.conf文件中有一行：
    local2.info       /var/log/test.log
    这样，字符串将写入test.log文件。
    
    
    
    
    8.1.4 创建守护进程
    创建守护进程如下：
    1. 调用fork()函数产生后台子进程。首先调用fork(),然后终止父进程，留下子进程继续进行。如果进程是以shell命令
    方式从前台启动，当父进程终止时，shell就认为命令已经完成。可以自动使子进程在后台运行。同时，子进程属于父进程的进程组，
    从而保证了子进程不是所属组的组长进程，因此子进程可以掉哦用setid()函数产生新的会话期。
    
    2. 调用setid()函数产生新的会话期并失去控制终端。产生新的会话期后，进程成为新会话期的组长进程以及新进程组的组长进程，
    同时失去控制终端，。
    3. 忽略SIGHUP信号并再次调用fork()函数产生新子进程。第二次fork()函数的目的是确保守护进程将来即使打开一个终端设备，
    也不会自动获得控制终端。在SVR4中，当没有控制终端的会话头进程打开一个终端设备时(这个终端现在不是其他会话的控制终端)，
    该终端自动成为这个会话头的控制终端。但通过第二次调用fork()函数，可以确保这次生成的子进程不再是一个会话的头，
    因此它不会获得控制终端。由于会话期组长进程终止时会向会话期中的其他进程发送SIGHUP信号而造成其他进程终止，所以必须忽略该信号。
    
    4. 改变工作目录。 通常将目录改变到根目录上，这样它启动的目录也可以被卸掉。
    5. 关闭已经打开的文件描述符，并打开一个空设备，把它复制到标准输出，标准错误上。
    这是由于守护进程的程序可能包括一些库或重用一些其他程序代码，库中可能存在向标准输出或标准错误输出的函数调用。
    因为关闭了所有描述符，这些函数返回错误而可能造成程序终止。如果将标准输出和标准错误映射到空设备上，将不会产生任何影响。
    6. 用openlog()函数建立与syslogd的连接。
    
    创建守护进程的典型代码：
    #define MAXFD 64
    void daemon_init(const char *pname, int facility)
    {
        int i ;
        pid_t pid;
        if ((pid = fork()) != 0)  // 创建第一个子进程
        {
            exit(0); // 终止父进程
        }
        /*第一个子进程继续*/
        setsid();    // 成为会话头
        signal(SIGHUP, SIG_IGN); // 忽略SIGHUP信号
        if ((pid = fork()) != 0)
        {
            exit(0); // 第一个子进程终止
        }
        /*第二个子进程继续*/
        
        chdir("/"); // 改变工作目录
        umask(0); /*清除文件模式创建掩码，使新文件的权限位不受原先文件模式创建掩码的权限位的影响*/
        
        for(i = 0; i < MAXFD; ++i) // 关闭所有打开的文件描述字
        {
            close(i);
        }
        openlog(pname, LOG_PID, facility); // 用syslogd处理错误
    }
    
    
