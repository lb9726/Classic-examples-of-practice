#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <string.h>
#include <sys/stat.h>

#define ERR_EXIT(m) \
    do\
{\
    perror(m);\
    exit(EXIT_FAILURE);\
    }\
    while (0);\

void creat_daemon(void);

int main(void)
{
    time_t t;
    int fd;
    creat_daemon();
    while(1)
    {
        fd = open("daemon.log",O_WRONLY|O_CREAT|O_APPEND,0644);
        if (-1 == fd)
        {
            ERR_EXIT("open error");
        }
        t = time(0);
        char *buf = asctime(localtime(&t));
        write(fd, buf, strlen(buf));
        close(fd);
        sleep(60);
    }
    return 0;
}
void creat_daemon(void)
{
    pid_t pid;
    pid = fork();
    if( -1 == pid)
    {
        ERR_EXIT("fork error");
    }
    if(pid > 0 )
    {
        exit(EXIT_SUCCESS);
    }
    if(setsid() == -1)
    {
        ERR_EXIT("SETSID ERROR");
    }
    chdir("/");
    int i;
    for( i = 0; i < 3; ++i)
    {
        close(i);
        open("/dev/null", O_RDWR);
        dup(0);
        dup(0);
    }
    umask(0);
    return;
}


结果显示：当我一普通用户执行a.out时，进程表中并没有出现新创建的守护进程，但当我以root用户执行时，成功了，并在/目录下创建了daemon.log文件，cat查看后确实每个一分钟写入一次。为什么只能root执行，那是因为当我们创建守护进程时，已经将当前目录切换我/目录，所以当我之后创建daemon.log文件是其实是在/目录下，那肯定不行，因为普通用户没有权限，或许你会问那为啥没报错呢？其实是有出错，只不过我们在创建守护进程时已经将标准输入关闭并重定向到/dev/null，所以看不到错误信息。

修改daemon.log 为 /home/libo/Desktop/daemon.log，使用普通用户也可以运行
libo@ubuntu:~/Desktop/Repository/Classic-examples-of-practice/004-网络编程/001-D
aemon-守护进程/other-Daemon$ ps -ef |grep myself
libo     22263  2172  0 08:43 ?        00:00:00 ./myself
libo     22271 22172  0 08:44 pts/15   00:00:00 grep --color=auto myself


四，利用库函数daemon()创建守护进程

其实我们完全可以利用daemon()函数创建守护进程，其函数原型：

#include <unistd.h>

int daemon(int nochdir, int noclose);


DESCRIPTION 
       The daemon() function is for programs wishing to detach themselves from 
       the controlling terminal and run in the background as system daemons.

       If nochdir is zero, daemon()  changes  the  process’s  current  working 
       directory to the root directory ("/"); otherwise,

       If  noclose is zero, daemon() redirects standard input, standard output 
       and standard error to /dev/null; otherwise,  no  changes  are  made  to 
       these file descriptors. 

功能：创建一个守护进程
参数：
nochdir：=0将当前目录更改至“/”
noclose：=0将标准输入、标准输出、标准错误重定向至“/dev/null”

返回值：成功：0   失败：-1

现在我们利用daemon()改写刚才那个程序：



