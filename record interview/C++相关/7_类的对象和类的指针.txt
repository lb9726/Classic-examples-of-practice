 C++类的对象和类的指针的区别、指针和引用的区别

 
#include <iostream>  
#include <string>  
using namespace std;  
  
class Student  
{  
    public:  
    static int number;  
    string name;  
  
public:  
    Student() { }  
  
    void set(string str)  
    {  
        name = str;  
        number++; // 调用静态数据成员  
    }  
  
    void print() // 态成员函数 print()  
    {  
        std::cout < < name < <" : The number of the students is " < < number < < " numbers." < < std::endl; // 调用静态数据成员  
    }  
};  
  
int Student::number = 0; // 静态数据成员初始化  
  
int main(int argc, char** argv)  
{  
    Student* s1;  
    s1 = new Student();  
    s1->set("111");  
  
    Student s2;  
    s2.set("222");  
  
    s1->print();  
    s2.print();  
  
    return 0;  
}  
对于类student ，定义了一个对象和一个指针。
1、1）类的指针:他是一个内存地址值,他指向内存中存放的类对象(包括一些成员变量所赋的值)  
     2）对象,他是利用类的构造函数在内存中分配一块内存(包括一些成员变量所赋的值). 
2、在应用时:  
        1）引用成员:   对象用"   .   "操作符;   指针用"   ->   "操作符.  
        2）生命期:     若是成员变量,则是类的析构函数来释放空间;
                                 若是函数中的临时变量,则作用域是该函数体内.
                                 而指针,则需利用delete 在相应的地方释放分配的内存块.  
           注意:用new ,一定要delete
        3）指针可以实现多态，直接用对象不行
        4）在类的声明尚未完成的情况下，可以声明指向该类的指针，但是不可声明该类的对象.
        5）父类的指针可以指向子类的对象
        6）定义对象实例时，分配了内存。指针变量则未分配类对象所需内存，除非new了
 指针变量是间接访问，但可实现多态（通过父类指针可调用子类对象），并且没有调用构造函数。
直接声明可直接访问，但不能实现多态，声明即调用了构造函数（已分配了内存）。
3、类的对象:用的是内存栈,是个局部的临时变量.  
 
      类的指针:用的是内存堆,是个永久变量,除非你释放它.  
   
4、当类是有虚函数的基类,Func是它的一个虚函数,则调用Func时:  
       1）类的对象:调用的是它自己的Func;  
       2）类的指针:调用的是分配给它空间时那种类的Func;
5、类型决定了你能做什么.
其实作用基本一样都是为了调用类的成员变量和成员函数用的
当你希望明确使用这个类的时候，最好使用对象，如果你希望使用C++中的动态绑定，则最好使用指针或者引用，指针和引用用起来更灵活，容易实现多态等

C++的精髓之一就是多态性，只有指针或者引用可以达到多态。对象不行
 
用指针：
第一，实现多态。
第二，在函数调用，传指针参数。不管你的对象或结构参数多么庞大，你用指针，传过去的就是4个字节。如果用对象，参数传递占用的资源就太大了

二、指针和引用的区别

1.指针和引用的定义和性质区别：
(1)指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。如：
int a = 1;int *p = &a;
int a = 1;int &b = a;
上面定义了一个整形变量和一个指针变量p，该指针变量指向a的存储单元，即p的值是a存储单元的地址。
而下面2句定义了一个整形变量a和这个整形a的引用b，事实上a和b是同一个东西，在内存占有同一个存储单元。
(3)指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）
(4)指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；
(5)指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。
(6)"sizeof引用"得到的是所指向的变量(对象)的大小，而"sizeof指针"得到的是指针本身的大小；
(7)指针和引用的自增(++)运算意义不一样；
2.指针和引用作为函数参数进行传递时的区别。
(1)指针作为参数进行传递：
 
#include<iostream>  
using namespace std;  
  
void swap(int *a,int *b)  
{  
　　int temp = *a;  
　　*a = *b;  
　　*b = temp;  
}  
  
int main(void)  
{  
　　int a = 1,b = 2;  
　　swap(&a,&b);  
　　cout<<a<<" "<<b<<endl;  
　　system("pause");  
　　return 0;  
}  
结果为2 1；
用指针传递参数，可以实现对实参进行改变的目的，是因为传递过来的是实参的地址，因此使用*a实际上是取存储实参的内存单元里的数据，即是对实参进行改变，因此可以达到目的。
再看一个程序;
 
#include<iostream>  
using namespace std;  
  
void test(int *p)  
{  
    int a = 1;  
    p = &a;  
    cout<<p<<" "<<*p<<endl;  
}  
  
int main(void)  
{  
    int *p = NULL;  
    test(p);  
    if(p == NULL)  
    cout<<"指针p为NULL"<<endl;  
    system("pause");  
    return 0;  
}  

运行结果为：
0x22ff44 1
指针p为NULL
事实上，在main函数中声明了一个指针p，并赋值为NULL，当调用test函数时，事实上传递的也是地址，只不过传递的是值地址。也就是说将指针作为参数进行传递时，事实上也是值传递，只不过传递的是地址。
当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，即上面程序main函数中的p 和 test函数中使用的p不是同一个变量，只是2个p指向同一个存储单元，那么在test函数中对p进行修改，并不会影响到main函数中的p的值。
如果要想达到也同时修改的目的的话，就得使用引用了。
2.将引用作为函数的参数进行传递。
在讲引用作为函数参数进行传递时，实质上传递的是实参本身，即传递进来的不是实参的一个拷贝，因此对形参的修改其实是对实参的修改，所以在用引用进行参数传递时，不仅节约时间，而且可以节约空间。
看下面这个程序：
 
// testtest.cpp : 定义控制台应用程序的入口点。  
//  
  
#include "stdafx.h"  
#include <stdio.h>  
#include <iostream>  
#include <vector>  
using namespace std;  
int ab = 0;  
  
void test(int &a)  
{  
    a++;  
    cout<<&a<<" "<<a<<endl;  
}  
  
int _tmain(int argc, _TCHAR* argv[])  
{  
    int a = 1;  
    cout<<&a<<" "<<a<<endl;  
    test(a);  
    cout<<&a<<" "<<a<<endl;  
    system("pause");  
  
    return 0;  
}  

输出结果为： 0x22ff44 1
                       0x22ff44 2
                       0x22ff44 2

再看下这个程序：
这足以说明用引用进行参数传递时，事实上传递的是实参本身，而不是拷贝。
所以在上述要达到同时修改指针的目的的话，就得使用引用了。﻿﻿










