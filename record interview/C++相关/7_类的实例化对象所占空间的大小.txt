#include <iostream>
using namespace std;

class Base
{
    
};

class Son
{
    char a;
    int b;
    void F()
    {
        cout <<"is Fuction F()"<<endl;
    }
};

int main()
{
    Base b;
    cout<<"sizeof(b) = "<< sizeof(b) <<endl;
    Son s;
    cout<<"sizeof(s) = "<< sizeof(s) <<endl;
    return 0;
}
/*
sizeof(b) = 1  当类为空的函数体时，大小为1.不为0,因为如果
class的sizeof不能为0，因为需要能允许把 class 实例放到数组里。如果sizeof是0，那么数组的sizeof呢，也是0？
那么数组里有多少个元素呢？0/0？无穷多或N/A个？
sizeof(s) = 8
*/


一个类的实例化对象所占空间的大小？ 注意不要说类的大小,是类的对象的大小。 
首先，类的大小是什么？确切的说，类只是一个类型定义，它是没有大小可言的。 
用sizeof运算符对一个类型名操作，得到的是具有该类型实体的大小。add charles 空结构体：struct d{} 的sizeof也是1。

如果

Class A; A obj; 

那么sizeof(A) == sizeof(obj) 那么sizeof(A)的大小 和 成员的大小总和 是什么关系呢? 很简单，一个对象的大小大于等于所有非静态成员大小的总和。 
为什么是大于等于而不是正好相等呢？超出的部分主要有以下两方面： 
(1) C++对象模型本身 对于具有虚函数的类型来说，需要有一个方法为它的实体提供类型信息(RTTI)和虚函数入口，常见的方法是建立一个虚函数入口表，这个表可为相同类型的对象共享，因此对象中需要有一个指向虚函数表的指针，此外，为了支持RTTI，许多编译器都把该类型信息放在虚函数表中。但是，是否必须采用这种实现方法，C++标准没有规定，但是这几户是主流编译器均采用的一种方案。 
(2) 编译器优化 因为对于大多数CPU来说，CPU字长的整数倍操作起来更快，因此对于这些成员加起来如果不够这个整数倍，有可能编译器会插入多余的内容凑足这个整数倍，此外，有时候相邻的成员之间也有可能因为这个目的被插入空白，这个叫做“补齐”(padding)。所以，C++标准紧紧规定成员的排列按照类定义的顺序，但是不要求在存储器中是紧密排列的。 

基于上述两点，可以说用sizeof对类名操作，得到的结果是该类的对象在存储器中所占据的字节大小，由于静态成员变量不在对象中存储，因此这个结果等于各非静态数据成员（不包括成员函数）的总和加上编译器额外增加的字节。后者依赖于不同的编译器实现，C++标准对此不做任何保证。 
C++标准规定类的大小不为0，空类的大小为1，当类不包含虚函数和非静态数据成员时，其对象大小也为1。 如果在类中声明了虚函数（不管是1个还是多个），那么在实例化对象时，编译器会自动在对象里安插一个指针指向虚函数表VTable，在32位机器上，一个对象会增加4个字节来存储此指针，它是实现面向对象中多态的关键。而虚函数本身和其他成员函数一样，是不占用对象的空间的。 我们来看下面一个例子：（此例子在Visual C++编译器中编译运行）

例如：
#include <iostream>
using namespace std;

class A 
{ 
};

class B 
{
    char ch;
    void func() { }
};

class C 
{
    char ch1; //占用1字节
    char ch2; //占用1字节
    virtual void func() { }
};

class D 
{
    int in;
    virtual void func() { }
};

int main() 
{
    A a;
    B b;
    C c;
    D d;
    cout<<sizeof(a)<<endl;//result=1   
    cout<<sizeof(b)<<endl;//result=1   //对象c扩充为2个字，但是对象b为什么没扩充为1个字呢（空类的对象一个字节，含一个char的类类对象也为一个字节。）？因为B类只有一个成员变量，普通成员函数不占用内存。
    cout<<sizeof(c)<<endl;//result=8   
    //对象c实际上只有6字节有用数据，但是按照上面第二点编译器优化，编译器将此扩展为两个字（add charles 字节对齐），即8字节
    cout<<sizeof(d)<<endl;//result=8   
}

/*
运行结果：64位操作系统
1  空的类的对象为1
1  普通成员函数不占用内存。
16  对于具有虚函数的类型来说，需要有一个方法为它的实体提供类型信息(RTTI)和虚函数入口，常见的方法是建立一个虚函数入口表，这个表可为相同类型的对象共享，因此对象中需要有一个指向虚函数表的指针 ch1 为1, ch2 为1,加上虚函数的指针8,所以前面的2,需要补足6个字节，总共16
16  int in为4,后面的指针为8,最终内存对齐的为16  
*/


综上所述： 
一个类中，虚函数、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间的。 
对象大小 = vptr(可能不止一个，这个很难确定，不过试过，类中定义了一个virtual函数，仍然为占用4个字节) + 所有非静态数据成员大小 + Aligin字节大小（依赖于不同的编译器）


c++空类实例大小不是0原因？ 
初学者在学习面向对象的程序设计语言时，或多或少的都些疑问，我们写的代码与最终生编译成的代码却　大相径庭，我们并不知道编译器在后台做了什么工作．这些都是由于我们仅停留在语言层的原因，所谓语言层就是教会我们一些基本的语法法则，但不会告诉我们为什么这么做？今天和大家谈的一点感悟就是我在学习编程过程中的一点经验，是编译器这方面的一个具体功能． 
首先：我们要知道什么是类的实例化，所谓类的实例化就是在内存中分配一块地址． 
那我们先看看一个例子：

#include<iostream>
using namespace std;
class a 
{
};
class b
{
};
class c:public a
{
    virtual void fun() = 0;
};

class d:public b, public c
{
};
int main()
{
    cout<<"sizeof(a) = "<<sizeof(a)<<endl;
    cout<<"sizeof(b) = "<<sizeof(b)<<endl;
    cout<<"sizeof(c) = "<<sizeof(c)<<endl;
    cout<<"sizeof(d) = "<<sizeof(d)<<endl;
    return  0;
}

/*
程序执行的输出结果为：
sizeof(a) =1
sizeof(b) = 1
sizeof(c) = 4
sizeof(d) = 8 
#charlse# 这里错误，这个调试中是4
*/






































