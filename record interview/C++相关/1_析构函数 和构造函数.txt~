请讲一讲析构函数和虚函数的用法和作用?
【参考答案】析构函数是特殊的类成员函数,它没有返回类型,没有参数,不能随意调用,也没有重载,只有在类对象的生命期结束的时候,由系统自动调用。有适放内存空间的作用。
虚函数是C++多态的一种表现, 使用虚函数,我们可以灵活的进行动态绑定,当然是以一定的开销为代价。

在C++中有没有纯虚构造函数?
【标准答案】构造函数不能是虚的。只能有虚的析构函数。


构造函数可否是虚函数,为什么?析构函数呢,可否是纯虚的呢?
【参考答案】
构造函数不能为虚函数,要构造一个对象,必须清楚地知道要构造什么,否则无法构造一个对象。
析构函数可以为纯虚函数。

基类的析构函数不是虚函数,会带来什么问题?
【参考答案】派生类的析构函数用不上,会造成资源的泄漏。

C++中哪些函数不能被声明为虚函数?
【标准答案】
普通函数(非成员函数),构造函数,内联成员函数、静态成员函数、友元函数。
(1)虚函数用于基类和派生类,普通函数所以不能
(2)构造函数不能是因为虚函数采用的是虚调用的方法,允许在只知道部分信息的情况的
工作机制,特别允许调用只知道接口而不知道对象的准确类型的方法,但是调用构造函数即是要创建一个对象,那势必要知道对象的准确类型。
(3)内联成员函数的实质是在调用的地方直接将代码扩展开
(4)继承时,静态成员函数是不能被继承的,它只属于一个类,因为也不存在动态联编等
(5)友元函数不是类的成员函数,因此也不能被继承

C++中virtual与inline的含义分别是什么?
【参考答案】 在基类成员函数的声明前加上virtual关键字,意味着将该成员函数声明为虚函数。
inline与函数的定义体放在一起,使该函数称为内联。inline是一种用于实现的关键字,而不是用于声明的关键字。
虚函数的特点;如果希望派生类能够重新定义基类的方法,则在基类中将该方法定义为虚方法,这样可以启用动态联编。
内联函数的特点;使用内联函数的目的是为了提高函数的运行效率。内联函数体的代码不能过长,因为内联函数省去调用函数的时间是以代码膨胀为代价的。内联函数不能包含循环语句,因为执行循环语句要比调用函数的开销大。

动态联编 和 静态联编
关于 动态联编 和 静态联编 这个概念，自己听了老师上课讲的课仍然没有明白原理。
那么既然这样，只能自己去学习了。
首先我们知道的是，动态联编 和 静态联编 都是多态性的一种体现。
关于面向对象的三个基本要素：封装（类型抽象）， 继承 和 多态。
首先我们从概念性上面了解了 动态联编 和 静态联编 的功能：实现了多态性。
然后我们从最最基本的开始讲解。

1.什么是 联编？
联编是指一个计算机程序自身彼此关联的过程,在这个联编过程中,需要确定程序中的操作调用(函数调用)与执行该操作(函数)的代码段之间的映射关系;按照联编所进行的阶段不同,可分为静态联编和动态联编;

仔细读读红色字体的那部分句子。我们就能很清楚的明白什么是联编了。给大家举个最通俗易懂的例子好了：
A类中有fun这个函数， B类中也有fun这个函数，现在我在类外的main函数里面调用fun 函数。
那么main函数就是函数调用，调用fun函数，
而A类中的fun函数和B类中的fun函数就是执行该操作的代码段
所以现在联编就是实现两者的映射关系。

class A  
{     
    void func() {cout<<"It's A"<<endl;  
};  
  
class B  
{     
    void func() {cout<<"It's B"<<endl;  
};  
int main()  
{  
    func();  
}  
联编就是决定将main函数中的func（）的函数调用映射到A中的func函数还是B中的func函数的过程。

2.静态联编 和 动态联编 的定义

知道了什么事联编，那么再来理解动态联编 和静态联编也就不难了


静态联编:
是指联编工作是在程序编译连接阶段进行的,这种联编又称为早期联编;因为这种联编是在程序开始运行之前完成的;
在程序编译阶段进行的这种联编又称静态束定;在编译时就解决了程序中的操作调用与执行该操作代码间的关系,确定这种关系又被称为束定;编译时束定又称为静态束定;

拿上面的例子来说，静态联编就是在编译的时候就决定了main函数中调用的是A中的func还是B中的func。一旦编译完成，那么他们的映射关系就唯一确定了。

动态联编:
编译程序在编译阶段并不能确切地知道将要调用的函数,只有在程序执行时才能确定将要调用的函数,为此要确切地知道将要调用的函数,要求联编工作在程序运行时进行,这种在程序运行时进行的联编工作被称为动态联编,或动态束定,又叫晚期联编;C++规定:动态联编是在虚函数的支持下实现的;

动态联编在编译的时候还是不知道到底应该选择哪个func函数，只有在真正执行的时候，它才确定。
静态联编和动态联编都是属于多态性的,它们是在不同的阶段进对不同的实现进行不同的选择;

其实多态性的本质就是选择。因为存在着很多选择，所以就有了多态。

3.静态联编
首先还是拿个例子来说事吧。
#include <iostream>  
using namespace std;  
class shape{  
  public:  
    void draw(){cout<<"I am shape"<<endl;}  
    void fun(){draw();}  
};  
class circle:public shape{  
  public:  
    void draw(){cout<<"I am circle"<<endl;}  
};  
void main(){  
    circle  oneshape;  
    oneshape.fun();  
}  
现在我们详细具体定义了一开始的A类和B类以及func函数。让我们来分析一下：
调用oneshape.fun()的时候，进入类shape中的fun函数。
现在我们的问题就是：fun函数调用的draw到底是shape里面的draw还是circle中的draw？？

答案是：它调用了cshape这个基类的draw函数。所以输出了 I am shape
那么一直困扰我的问题是：为什么调用基类的draw而不是派生类中得draw呢？
书上好像没有具体讲，上课的时候老师那也根本不会讲。
自己想了一下，应该可以从汇编的角度理解：
1.调用oneshape.fun()，这里是一个跳转指令，进入类shape中的fun函数所在的代码段
2.类shape的代码段是依次顺序放置的。进入fun函数后，现在我们要调用draw的地址。
由于没有另外的数据结构来保存draw的地址，所以程序所知道的，必然只有在shape类中的draw地址了，仅仅用一个跳转指令
在我的vs2010的反汇编调试窗口下是这样的一句代码：
013B1546  call        shape::draw (13B10F5h) 
很明确这里指出了shape::draw，也就确定了映射关系，完成了联编。



4.动态联编
从第3节中我们看到了静态联编的不足（大概教材中就是这样说的）。
刚才我讲了，由于没有另外的数据结构来保存draw的地址，所以程序所知道的，必然之后在shape类中的draw地址了，仅仅用一个跳转指令
所以我们想实现动态编联，其实就是想弄出个数据结构来，这个数据结构用来存放 映射关系，也就是联编。
所以c++才搞了个虚函数。其实虚函数的本质就是搞了个数据结构。也就是虚函数表
关于虚函数表，自己不想多扯了，扯出来又是一大串，大家自己去下面的博客学习吧。
http://blog.csdn.NET/haoel/article/details/1948051/

4.1虚函数
大家都不喜欢理解概念。我也不喜欢。但是概念毕竟是要紧的。我已经跟大家说明了为什么要引入虚函数。所以接下来请大家耐心看看下面这段概念吧：
虚函数是动态联编的基础;虚函数是成员函数,而且是非静态的成员函数;虚函数在派生类中可能有不同的实现,当使用这个成员函数操作指针或引用所标识的对象时,对该成员函数的调用采用动态联编方式,即:在程序运行时进行关联或束定调用关系;
动态联编只能通过指针或引用标识对象来操作虚函数;如果采用一般的标识对象来操作虚函数,将采用静态联编的方式调用虚函数;
如果一个类具有虚函数,那么编译器就会为这个类的对象定义一个指针成员,并让这个指针成员指向一个表格,这个表格里面存放的是类的虚函数的入口地址;比如:一个基类里面有一些虚函数,那么这个基类就拥有这样一个表,它里面存放了自己的虚函数的入口地址,其派生类继承了这个虚函数表,如果在派生类中重写/覆盖/修改了基类中的虚函数,那么编译器就会把虚函数表中的函数入口地址修改成派生类中的对应虚函数的入口地址;这就为类的多态性的实现提供了基础;

虚函数按照其声明顺序存放于虚函数表中;
父类的虚函数存放在子类虚函数的前面;
多继承中,每个父类都有自己的虚函数表;
子类的成员函数被存放于第一个父类的虚函数表中;

4.2动态联编举例
最后给大家举个例子，在第三节的那个例子上，下面的代码仅仅是多了一个词：virtual
#include <iostream>  
using namespace std;  
class shape{  
  public:  
    void virtual draw(){cout<<"I am shape"<<endl;}//这里设定了draw是虚函数  
    void fun(){draw();}  
};  
class circle:public shape{  
  public:  
    void draw(){cout<<"I am circle"<<endl;}//虽然没有说明circle类中的draw是虚函数，但是circle其实继承了virtual性质  
};  
void main(){  
    circle  oneshape;  
    oneshape.fun();  
}  

现在我们再来运行一下程序，输出就变成了I am circle


#include<iostream>
using namespace std;
class ClxBase{
public:
    ClxBase() {};
    ~ClxBase() {cout << "Output from the destructor of class ClxBase!" << endl;};

    void DoSomething() { cout << "Do something in class ClxBase!" << endl; };
};

class ClxDerived : public ClxBase{
public:
    ClxDerived() {};
    ~ClxDerived() { cout << "Output from the destructor of class ClxDerived!" << endl; };

    void DoSomething() { cout << "Do something in class ClxDerived!" << endl; };
};

int   main()
{  
  ClxDerived *p =  new ClxDerived;
  p->DoSomething();
  delete p;
  return 0;
}

/*
Do something in class ClxDerived!
Output from the destructor of class ClxDerived!
Output from the destructor of class ClxBase!

这段代码中基类的析构函数不是虚函数,在main函数中用继承类的指针去操作继承类的成员,
释放指针P的过程是:先释放继承类的资源,再释放基类资源. 
*/


#include<iostream>
using namespace std;
class ClxBase{
public:
    ClxBase() {};
    ~ClxBase() {cout << "Output from the destructor of class ClxBase!" << endl;};

    void DoSomething() { cout << "Do something in class ClxBase!" << endl; };
};

class ClxDerived : public ClxBase{
public:
    ClxDerived() {};
    ~ClxDerived() { cout << "Output from the destructor of class ClxDerived!" << endl; };

    void DoSomething() { cout << "Do something in class ClxDerived!" << endl; }
};
int   main()
{  
  ClxBase *p =  new ClxDerived;
  p->DoSomething();
  delete p;
  return 0;
} 

/*
Do something in class ClxBase!
Output from the destructor of class ClxBase!

这段代码中基类的析构函数同样不是虚函数,不同的是在main函数中用基类的指针去操作继承类的成员,释放指针P的过程是:只是释放了基类的资源,而没有调用继承类的析构函数.调用　　dosomething()函数执行的也是基类定义的函数.
    一般情况下,这样的删除只能够删除基类对象,而不能删除子类对象,形成了删除一半形象,造成内存泄漏.
    在公有继承中,基类对派生类及其对象的操作,只能影响到那些从基类继承下来的成员.如果想要用基类对非继承成员进行操作,则要把基类的这个函数定义为虚函数.

    析构函数自然也应该如此:如果它想析构子类中的重新定义或新的成员及对象,当然也应该声明为虚的.
*/


#include<iostream>
using namespace std;
class ClxBase{
public:
    ClxBase() {};
    virtual ~ClxBase() {cout << "Output from the destructor of class ClxBase!" << endl;};
    virtual void DoSomething() { cout << "Do something in class ClxBase!" << endl; };
};

class ClxDerived : public ClxBase{
public:
    ClxDerived() {};
    ~ClxDerived() { cout << "Output from the destructor of class ClxDerived!" << endl; };
    void DoSomething() { cout << "Do something in class ClxDerived!" << endl; };
};

int  main()
{  
  ClxBase *p =  new ClxDerived;
  p->DoSomething();
  delete p;
  return 0;
}  

/*
Do something in class ClxDerived!
Output from the destructor of class ClxDerived!
Output from the destructor of class ClxBase!

这段代码中基类的析构函数被定义为虚函数,在main函数中用基类的指针去操作继承类的成员,释放指针P的过程是:只是释放了继承类的资源,再调用基类的析构函数.调用dosomething()函数执行的也是继承类定义的函数.  

    如果不需要基类对派生类及对象进行操作,则不能定义虚函数,因为这样会增加内存开销.当类里面有定义虚函数的时候,编译器会给类添加一个虚函数表,里面来存放虚函数指针,这样就会增加类的存储空间.所以,只有当一个类被用来作为基类的时候,才把析构函数写成虚函数.

    析构函数自然也应该如此:如果它想析构子类中的重新定义或新的成员及对象,当然也应该声明为虚的.
*/


一、 指针调用情况

  1、 父类指针new子类对象，而不能为子类指针new父类对象

       因为子类包含有父类，把子指针赋给父指针时其实只是把子类中父类部分的地址赋给了父类指针而已，而父类里没有包含子类，所以不能复制，建议楼主变个程序然后再对照看下汇编就清楚了

因为子类继承了父类，所以说他里面就有了父类的函数，所以可以指向啊，但是父类里没有子类的函数，就像结构体指针一样，他怎么能指向一个结构体里根本就没有的变量呢

（1） 如果以一个基础类指针指向一个衍生类对象(派生类对象)，那么经由该指针只能访问基础类定义的函数（静态联翩）


（2） 如果以一个衍生类指针指向一个基础类对象，必须先做强制转型动作（explicit cast），这种做法很危险，也不符合生活习惯，在程序设计上也会给程序员带来困扰。（一般不会这么去定义）
3，如果基础类和衍生类定义了相同名称的成员函数，那么通过对象指针调用成员函数时，到底调用那个函数要根据指针的原型来确定，而不是根据指针实际指向的对象类型确定。


虚拟函数就是为了对“如果你以一个基础类指针指向一个衍生类对象，那么通过该指针，你只能访问基础类定义的成员函数”这条规则反其道而行之的设计。
如果你预期衍生类由可能重新定义一个成员函数，那么你就把它定义成虚拟函数（ virtual ）。
polymorphism就是让处理基础类别对象的程序代码能够通透的继续适当地处理衍生类对象。
纯虚拟函数：
virtual void myfunc ( ) = 0;
纯虚拟函数不许定义其具体动作，它的存在只是为了在衍生类钟被重新定义。只要是拥有纯虚拟函数的类，就是抽象类，它们是不能够被实例化的（只能被继承）。如果一个继承类没有改写父类中的纯虚函数，那么他也是抽象类，也不能被实例化。
抽象类不能被实例化，不过我们可以拥有指向抽象类的指针，以便于操纵各个衍生类。
虚拟函数衍生下去仍然是虚拟函数，而且还可以省略掉关键字“virtual”。


总结：一般都是将子类的地址赋值给父类的指针，用来实现多态，拥有纯虚函数的类是抽象类，它们不能被实例化，只能被继承。如果一个继承类没有改写父类中的纯虚函数，那么他也是抽象类，也不能被实例化。


1，直接用基类指针引用基类对象
2，直接用派生类指针引用派生类对象
3，用基类指针引用一个派生类对象，由于派生类对象也是基类的对象，所以这种引用是安全的，
但是只能引用基类成员。若试图通过基类指针引用那些只在派生类中才有的成员，编译器会报告语法错误。（解决该问题的答案是虚函数和多态性）
4，用派生类指针引用基类的对象。这种引用方式会导致语法错误。派生类指针必须先强制转换为基类指针，这种方法是不安全的。 
而在侯捷的深入浅出MFC中第二章C++重要性质中:
1、如果你以一个"基类之指针"指向一个"派生类之对象"，那么经由该指针你只能调用该基类所定义的函数
2、如果你以一个“派生类之指针”指向一个“基类之对象”，你必须先做明显的转型操作(explicit cast)，这种作法很危险。
3、如果基类和派生类都定义了“相同名称之函数”，那么通过对象指针调用成员函数时，到底调用了那个函数，必须视该指针的原始类型而定，而不是视指针实际所指的对象的类型而定，这与第1点其实意义相通。


析构函数误区：
在单例模式之中，单例的析构函数中delete instance之后，又在使用到的地方delete 这个指针，就会造成析构函数死循环
因为delete会自动调用析构函数，而且在析构函数中不能delete 自己的对象，否则会造成析构函数死循环















