C语言函数指针（指向函数的指针）

一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似。我们可以把函数的这个首地址（或称入口地址）赋予一个指针变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是函数指针。

函数指针的定义形式为：
returnType (*pointerName)(param list);
returnType 为函数返回值类型，pointerNmae 为指针名称，param list 为函数参数列表。参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称，这一点和函数原型非常类似。

注意( )的优先级高于*，第一个括号不能省略，如果写作returnType *pointerName(param list);就成了函数原型，它表明函数的返回值类型为returnType *。

【实例】用指针来实现对函数的调用。
纯文本复制
#include <stdio.h>
//返回两个数中较大的一个
int max(int a, int b){
    return a>b ? a : b;
}
int main(){
    int x, y, maxval;
    //定义函数指针
    int (*pmax)(int, int) = max;  //也可以写作int (*pmax)(int a, int b)
    printf("Input two numbers:");
    scanf("%d %d", &x, &y);
    maxval = (*pmax)(x, y);
    printf("Max value: %d\n", maxval);
    return 0;
}

运行结果：
Input two numbers:10 50↙
Max value: 50

第 14 行代码对函数进行了调用。pmax 是一个函数指针，在前面加 * 就表示对它指向的函数进行调用。注意( )的优先级高于*，第一个括号不能省略。

要求设置一绝对地址为0x67a9的整型变量的值为0xaa66?
【标准答案】
int *ptr;
ptr = (int *)0x67a9;
*ptr = 0xaa55;
或者使用下面的方法：
*(int * const)(0x67a9) = 0xaa55;


要对绝对地址0x100000赋值,我们可以用*((unsigned int*)0x100000) = 1234;
那么要是想让程序跳转到绝对地址是0x100000去执行,应该怎么做?

首先要将0x100000强制转换成函数指针,即:
(void (*)())0x100000
然后再调用它: 



嵌入式笔试题：想让程序跳转到绝对地址0x100000处执行，该如何做？

网上看到有如下答案：

*((void(*)(void))0x100000)();

经过在VC++6.0和Linux gcc4.4.3下测试，均不能通过编译。

VC++6.0报错：error C2100: illegal indirection

GCC报错：error: void value not ignored as it ought to be



应该是怎么写呢？

经过测试，有两种方法：

答案1.    (*(void(*)(void))0x100000)();

答案2.    ((void(*)(void))0x100000)();

仔细观察，第一种写法只是第一个*的位置不同，第二种写法少了一个*，但是都能正确编译通过，且正确执行。

为什么会有这两种答案呢？查阅资料后发现，与历史原因有关……

先来看看如下例子：

#include <stdio.h>  
void func(void)  
{  
    printf("hello.\n");  
}  
void main(void)  
{  
    printf("func = %d\n", func);  
    printf("&func = %d\n", &func);  
} 

两次打印结果相同！！！

按照&运算符本来的意义，它要求其操作数是一个对象，但函数名不是对象（函数是一个对象），本来&func是非法的，但很久以前有些编译器已经允许这样做，c/c++标准的制定者出于对象的概念已经有所发展的缘故，也承认了&func的合法性。
因此，对于func和&func可以这样理解，func是函数的首地址，它的类型是void ()，&func表示一个指向函数void func(void)这个对象的地址，它的类型是void (*)()，因此func和&func所代表的地址值是一样的，但类型不一样。func是一个函数，&func表达式的值是一个指针！


既然取不取址都可以，那么*不*也都可以……
所以，在调用一个函数的时候，也有两种方法，正如前面的两种答案。


#include <stdio.h>  
  
void func(void)  
{  
    printf("hello.\n");  
}  
  
void main()  
{  
    void (*func_p)(void) = func;        //定义一个函数指针，这个指针无返回值，无参数，指向fun函数  
      
    (*func_p)();  
    (func_p)();  
}

上面的两种调用方法也都是正确的，编译通过，正确执行。
其实，func_p(); 也是正确的调用方式……

更有甚者(*func)();  还是正确的……只是平时不这么用罢了（注意此处是func，不是func_p）暂且不考虑那么多调用方式（知道就好了），现在回过头来看看 (*(void(*)(void))0x100000)();  
((void(*)(void))0x100000)();  

到底是什么东东……

1.首先来认识一个新的数据类型，如：void (*)(void)，和 int* 类似的一个数据类型，只不过int*是一个指向int型的指针，而void (*)(void)是一个指向函数的指针，且这个函数无返回值，无参数。

2.然后给他外层加个括号，如：(void (*)(void))，这样是不是很像(int*)，我们在做强制类型转换的时候需要在类型外加个括号的是吧。

3.接着把0x100000强制转化为一个函数指针，即：(void(*)(void))0x100000

4.最后就是调用这个函数，外层再加个括号，后面在加一对括号（参考例二的形式），

如：((void(*)(void))0x100000)();就可以到绝对地址0x100000处去执行了……

或者(*(void(*)(void))0x100000)();只是加不加 * 的问题。上面例二中可以看出，在用函数指针调用一个函数时，加不加 * 都是可以的。

所以答案就出来了……



另外，你可能疑惑，按照例二中func_p(); 的形式，那么 (void(*)(void))0x100000();也应该对呀？

但是，实际测试，编译报错：error C2064: term does not evaluate to a function

为啥呢？我也不知道了……反正不管有没有 * ，记得加个括号就好了……

那为什么最开始的*((void(*)(void)0x100000))();不对呢？
因为没见过*func(); 这么用的……
如果要是外面再加一层括号就对了，如：(*((void(*)(void)0x100000))) ();
其实，把蓝色括号去掉（蓝色括号和绿色括号重复了），就又变成答案一了……
所以无论如何，最外层不能是* ，必须是括号！
因为没见过 *func(); 这么用的……












