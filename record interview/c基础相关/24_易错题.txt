请填写 bool , float, 指针变量 与“零值”比较的 if语句。
提示:这里“零值”可以是 0, 0.0 , FALSE 或者“空指针” 。
例如 int 变量 n 与“零值”比较的 if 语句为:
if ( n == 0 )  if ( n != 0 ) 以此类推。

请写出 bool flag 与“零值”比较的 if 语句:
if ( flag )  或者 if ( !flag )

if (flag == TRUE) 或 if (flag == 1) 或 if (flag == FALSE) 或 if (flag == 0) 都是不好的表达方式


请写出 float x 与“零值”比较的 if 语句:
【标准答案】 
const float EPSINON = 0.00001;
if ((x >= - EPSINON) && (x <= EPSINON)
不可将浮点变量用“==”或“!=”与数字比较,应该设法转化成“>=”或“<=”此类形式。

if (x == 0.0) 或 if (x != 0.0) 是错误的写法

请写出 char *p 与“零值”比较的 if 语句
【标准答案】 if (p == NULL) 或 if (p != NULL)

不良风格如下：
if (p == 0) 或 if (p != 0) 或 if (p) 或 if (!)


下面的代码输出是什么,为什么?
void foo(void)
{
    unsigned int a = 6;
    int b = -20;
    (a+b > 6)? puts("> 6") : puts("<= 6");
}
【参考答案】 这个问题测试你是否懂得C语言中的整数自动转换原则,我发现有些开发者懂得极少这些东西。不管如何,这无符号整型问题的答案是输出是“>6”。原因是当表达式中存在有符号类型和无符号类型时所有的数都自动转换为无符号类型。因此-20变成了一个非常大的正整数,所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题,你也就到了得不到这份工作的边缘。


float a,b,c ,问等式 (a+b)+c==(b+a)+c 和(a+b)+c==(a+c)+b 能否成立?
【参考答案】
两者都不行。在比较float或double时,不能简单地比较。
由于计算误差,相等的概率很低。应判断两数之差是否落在区间(-e,e)内。
这个e应比浮点数的精度大一个数量级。


(void *)ptr 和 (*(void**))ptr的结果是否相同?其中ptr为同一个指针。
(*(void**))ptr：分2 步看，void**是一个指向空类型指针的指针（-》一级指针-》地址），然后*（一个指向空类型指针的指针）=指向空类型的一级指针（取地址）


int a,b,c 请写函数实现c=a+b ,不可以改变数据类型,如将c改为long int,关键是如何处理溢出问题
【标准答案】
bool add (int a, int b,int *c)
{
    *c = a+b;
    return (a>0 && b>0 &&(*c<a || *c<b) || (a<0
        && b<0&&(*c>a || *c>b)));
}




int main()
{
    int x=3;
    printf("%d",x);
    return 1;
}
问函数既然不会被其它函数调用,为什么要返回1?
【标准答案】main中,c标准认为0表示成功,非0表示错误。具体的值是某中具体出错信息。

已知一个数组table,用一个宏定义,求出数据的元素个数。
#define NTBL(table) (sizeof(table)/sizeof(table[0]))


#define Max_CB 500
void LmiQueryCSmd(Struct MSgCB * pmsg)
{
    unsigned char ucCmdNum;
    ......
    for(ucCmdNum=0;ucCmdNum<Max_CB;ucCmdNum++)
    {   ......; }
}这段代码执行有什么问题?
【标准答案】死循环
unsigned char //无符号字符型 表示范围0~255
char //有符号字符型 表示范围-128~127


不能做switch()的参数类型是:
    switch的参数不能为实型。


一语句实现x是否为2的若干次幂的判断。
【参考答案】
void main() {
    int a;
    scanf(“%d”,&a);
    printf(“%c”,(a)&(a-1)?’n’:’y’);
// 若是打印y,否则n
}

如果是2的若干次幂，则二进制数只有一位是1,且应该是最高位为1,那么a&(a-1) 一定为0





