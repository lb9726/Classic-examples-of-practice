下面的声明都是什么意思?
(1) const int a;
(2) int const a;
(3) const int *a;
(4) int * const a;
(5) int const * const a ;
【标准答案】
(1)(2)两个的作用是一样,a是一个常整型数。 
第三个意味着a是一个指向常整型数的指针(也就是,整型数是不可修改的,但指针可以)。 
第四个意思a是一个指向整型 数的常指针(也就是说,指针指向的整型数是可以修改的,但指针是不可修改的)。
最后一个意味着a是一个指向常整型数的常指针(也就是说,指针指向的整型数 是不可修改的,同时指针也是不可修改的

const和指针一起使用是C语言中一个很常见的困惑之处，在实际开发中，特别是在看别人代码的时候，常常会因为这样而不好判断作者的意图，下面讲一下我的判断原则：const只修饰其后的变量，至于const放在类型前还是类型后并没有区别。
如：const int a和int const a都是修饰a为const。

注意*不是一种类型，如果*pType之前是某类型，那么pType是指向该类型的指针

一个简单的判断方法：指针运算符*，是从右到左，那么如：char const * pContent，可以理解为char const (* pContent)，即* pContent为const，而pContent则是可变的。

#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int main()
{
    int i=123;
    int j=456;
    int const a;
    const int b;
    const int *c;
    int const *d;
    int *const e;
//    int *f const;  Test_const.c:14:12: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘const’
//    int const * g const;  Test_const.c:15:19: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘const’
    int const * const g ;
    const int * const p;
    a = i;  // Test_const.c:17:5: error: assignment of read-only variable ‘a’
    b = j;  // Test_const.c:18:5: error: assignment of read-only variable ‘b’
    
    c = &i; // OK 
    *c = i; // Test_const.c:21:5: error: assignment of read-only location ‘*c’
    
    d = &i; // OK
    *d = i; // Test_const.c:24:5: error: assignment of read-only location ‘*d’
    
    e = &i; // Test_const.c:26:5: error: assignment of read-only variable ‘e’
    *e = i; // OK
    
    g = &i; // Test_const.c:29:5: error: assignment of read-only variable ‘g’
    *g = i; // Test_const.c:30:5: error: assignment of read-only location ‘*g’
 
    p = &i; // Test_const.c:33:5: error: assignment of read-only variable ‘p’
    *p = i; // Test_const.c:34:5: error: assignment of read-only location ‘*p’
    
    return 0;
}


下面分别用const限定不可变的内容是什么？
1）const在前面
const int nValue； //int是const
const char *pContent; //char是const, pContent可变
const char* const pContent; //pContent和*pContent都是const
2）const在后面，与上面的声明对等
int const nValue; //nValue是const
char const * pContent; //*pContent是const, pContent可变
char* const pContent; //pContent是const,*pContent可变
char const* const pContent; //pContent和*pContent都是const

const和指针一起使用是C语言中一个很常见的困惑之处，在实际开发中，特别是在看别人代码的时候，常常会因为这样而不好判断作者的意图，下面讲一下我的判断原则：const只修饰其后的变量，至于const放在类型前还是类型后并没有区别。
如：const int a和int const a都是修饰a为const。

注意*不是一种类型，如果*pType之前是某类型，那么pType是指向该类型的指针

一个简单的判断方法：指针运算符*，是从右到左，那么如：char const * pContent，可以理解为char const (* pContent)，即* pContent为const，而pContent则是可变的。

例二
int const * p1,p2;
p2是const；(*p1)是一整体，因此(*p1)是const，但p1是可变的。int * p1,p2只代表p1是指向整型的指针，要表示p1、p2都是指针是需写成int * p1,* p2。所以无论是* const p1,p2还是const * p1,p2，里面的*都是属于p1的。
例三
int const * const p1,p2;
p2是const，是前一个const修饰的，*p1也被前一个const修饰，而p1被后一个const修饰。
例四
int * const p1,p2;
p1是const，（* const p1）是整体，所以const不修饰p2。
例五
指针指向及其指向变量的值的变化
const在*的左边，则指针指向的变量的值不可直接通过指针改变（可以通过其他途径改变）；在*的右边，则指针的指向不可变。简记为“左定值，右定向”。
1）指针指向的变量的值不能变，指向可变
int x = 1;
int y = 2;
const int* px = &x;
int const* px = &x; //这两句表达式一样效果
px = &y; //正确，允许改变指向
*px = 3; //错误，不允许改变指针指向的变量的值
2）指针指向的变量的值可以改变，指向不可变
int x = 1;
int y = 2;
int* const px = &x;
px = &y; //错误，不允许改变指针指向
*px = 3; //正确，允许改变指针指向的变量的值
3）指针指向的变量的值不可变，指向不可变
int x = 1;
int y = 2;
const int* const px = &x;
int const* const px = &x;
px = &y; //错误，不允许改变指针指向
*px = 3; //错误，不允许改变指针指向的变量的值
补充
在c中，对于const定义的指针，不赋初值编译不报错，
int* const px;这种定义是不允许的。（指针常量定义的时候对其进行初始化）
int const *px;这种定义是允许的。（常指针可以再定义的时候不初始化）
但是，在C++中
int* const px;和const int* const px;会报错，const int* px;不报错。
必须初始化指针的指向int* const px = &x;const int* const px=&x;
强烈建议在初始化时说明指针的指向，防止出现野指针！



const 与 #define 的比较 ,const有什么优点?
【参考答案】
(1) const 常量有数据类型,而宏常量没有数据类型。编译器可以对前者进行类型安全检查。
而对后者只进行字符替换,没有类型安全检查,并且在字符替换可能会产生意料不到的错误(边际效应) 。
(2) 有些集成化的调试工具可以对 const 常量进行调试,但是不能对宏常量进行调试。

const 有什么用途?(请至少说明两种)
【标准答案】
(1)可以定义 const 常量
(2)const 可以修饰函数的参数、返回值,甚至函数的定义体。
被 const 修饰的东西都受到强制保护,可以预防意外的变动,能提高程序的健壮性。


#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL  
我在这想看到几件事情：  
 #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）  
 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。
  
 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。  
 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要



用宏定义写出swap(x,y),即交换两数。
【标准答案】
#define swap_add(x,y) (x) = (x)+(y); (y) = (x)-(y); (x) = (x)-(y)
这样写大数相加的时候容易导致数据溢出，因此可以使用异或运算防止溢出,但是宏只是字符的替换，好像不会溢出，执行相加运算时可能会导致溢出
#define swap_yihuo(x, y) (x) = (x)^(y); (y) = (x)^(y); (x) = (x)^(y)
使用异或运算时则不会溢出

#include<stdio.h>
#include<stdlib.h>
#include<string.h>

#define swap_add(x,y) (x) = (x)+(y); (y) = (x)-(y); (x) = (x)-(y)
#define swap_yihuo(x, y) (x) = (x)^(y); (y) = (x)^(y); (x) = (x)^(y)

int main()
{
    int a = 2147483647;
    int b = 2100000000;
    int c = 2147483647;
    int d = 2100000000;
    printf("before exchange a = %d, b = %d\n",a, b);
    swap_add(a, b);
    printf("after exchange a = %d, b = %d\n",a, b);
    
    printf("before exchange a = %d, b = %d\n",c, d);
    swap_yihuo(c, d);
    printf("after exchange a = %d, b = %d\n",c, d);
    return 0;
}

一般宏定义后不加分号；如果加了；可能会导致错误

（1）函数式宏定义的参数没有类型，预处理器只负责做形式上的替换，而不做参数类型检查，所以危险性高；但因为省去了函数的调用，返回，释放，所以效率比自定义函数高；

（2）调用真正函数的代码和调用函数式宏定义的代码编译生成的指令不同。

如果MAX是个普通函数，那么它的函数体return a > b ? a : b; 要编译生成指令，代码中出现的每次调用也要编译生成传参指令和call指令。而如果MAX是个函数式宏定义，这个宏定义本身倒不必编译生成指令，但是代码中出现的每次调用编译生成的指令都相当于一个函数体，而不是简单的几条传参指令和call指令。所以，使用函数式宏定义编译生成的目标文件会比较大。

（3）在执行复杂功能时，如递归，函数式宏定义往往会导致较低的代码执行效率。

尽管函数式宏定义和普通函数相比有很多缺点，但只要小心使用还是会显著提高代码的执行效率，毕竟省去了分配和释放栈帧、传参、传返回值等一系列工作，因此那些简短并且被频繁调用的函数经常用函数式宏定义来代替实现。


写一个“标准”宏,这个宏输入两个参数并返回较小的一个。
【标准答案】#define Min(X, Y) ((X)>(Y)?(Y):(X))//结尾没有;


以下是求一个数的平方的程序,请找出错误:
#define SQUARE(a)((a)*(a))
int a=5;
int b;
b=SQUARE(a++);
【标准答案】宏在预编译时会以替换的形式展开,仅仅会替换。
涉及到宏的地方,不要用++ --,标准中对此没有规定,因此最终结果将会依赖于不同的编译器。
执行程序的答案可能是25、也有可能是36。


带参宏与带参函数的区别(至少说出5点)?
                带参宏    带参函数
处理时间         编译时    运行时
参数类型         无        需定义
程序长度         变长      不变
占用存储空间     否 是
运行时间        不占运行时间 调用和返回时占


已知一个数组table,用一个宏定义,求出数据的元素个数。
【标准答案】
#define NTBL(table) (sizeof(table)/sizeof(table[0]))


#define dPS struct s *
typedef struct s * tPS;
以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢?(如果有的话)为什么?

【参考答案】这是一个非常微妙的问题,任何人答对这个问题(正当的原因)是应当被恭喜的。答案是:typedef更好。思考下面的例子:
dPS p1,p2;
tPS p3,p4;

第一个扩展为
struct s * p1, p2;
上面的代码定义p1为一个指向结构的指,p2为一个实际的结构,这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针


对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?
【标准答案】c用宏定义,c++用inline


在 C++ 程序中调用被 C 编译器编译后的函数,为什么要加 extern “C”?
【标准答案】
 C++语言支持函数重载,C 语言不支持函数重载。函数被 C++编译后在库中的名字与 C 语言的不同。
 假设某个函数的原型为: void foo(int x, int y); 
 该函数被 C 编译器编译后在库中的名字为_foo,而 C++编译器则会产生像_foo_int_int 之类的名字。 
 C++提供了 C 连接交换指定符号extern“C”来解决名字匹配问题。
 



















