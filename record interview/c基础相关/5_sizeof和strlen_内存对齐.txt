void main()
{
    char aa[10];
    printf(“%d”,strlen(aa));
}
会出现什么问题?打印结果是是多少?
【标准答案】
sizeof()和初不初始化,没有关系。
strlen()和初始化有关,打印结果值未知。strlen以'\0'作为结束条件

sizeof 是c语言的32个关键字之一
C语言中判断数据类型或者表达式长度符；不是一个函数，字节数的计算在程序编译时进行，而不是在程序执行的过程中才计算出来。

【冤枉的原因】：常常被人们误认为函数，其实不然。
【用例子证明】题目如下：
题目：下边哪项表述是错误的？
int  i;
A sizeof(int)  B sizeof(i)  C sizeof int   D sizeof i 
当我们在计算机上进行调试的时候发现，D居然是对的，说明什么问题，他肯定不是函数，函数没关键字咋能行呢？想想看在int前边可以加static、unsigned、signed修饰，怎么可能用sizeof修饰呢？所以C选项肯定是错误的。
【sizeof的扩展】
   既然sizeof是用于侧变量或类型所占的资源数目，是否可以对下边的内容进行测试呢？
   sizeof((int*)malloc(4*sizeof(int)));
   sizeof(void);
答案是：以上两者不能测出，因为sizeof可以测出的是在编译阶段就可以确定的东西。而malloc()在运行阶段才可以确定，所以是测不出的。


内存对齐相关问题：一般均是以32位系统作为标准的
#include <stdio.h>  
#include <string.h> 
#include <stdlib.h>

typedef struct A
{
	char t;
	char k;
	unsigned short i;
	unsigned long m;
} A;

void Test_strlen_types()
{
	printf("sizeof(char) = %ld\n",sizeof(char));
	printf("sizeof(short) = %ld\n",sizeof(short));
	printf("sizeof(int) = %ld\n",sizeof(int));
	printf("sizeof(float) = %ld\n",sizeof(float));
	printf("sizeof(double) = %ld\n",sizeof(double));
	printf("sizeof(long) = %ld\n",sizeof(long));
	printf("sizeof(char *) = %ld\n",sizeof(char *));
	printf("sizeof(int *) = %ld\n",sizeof(int *));
}

int main()
{
	Test_strlen_types();
	printf("\n");
	printf("sizeof(A) = %ld\n", sizeof(A));
	return 0;
}

这是64位机器上的运行结果：
sizeof(char) = 1
sizeof(short) = 2
sizeof(int) = 4
sizeof(float) = 4
sizeof(double) = 8
sizeof(long) = 8
sizeof(char *) = 8
sizeof(int *) = 8
sizeof(A) = 16


其中32位机器的结果为：
sizeof(char) = 1
sizeof(short) = 2
sizeof(int) = 4
sizeof(float) = 4
sizeof(double) = 8
sizeof(long) = 4
sizeof(char *) = 4
sizeof(int *) = 4
sizeof(A) = 8



typedef struct A
{
	char str;
	short k;
	int m;
}A;

sizeof(A) = 8 无论是32还是64位的操作系统都一样的

struct name2{
	char str;  1+3
	int num;   4
	short x;   2
};求sizeof(name2)?
10%4 != 0,取整12


联合体sizeof的计算方式

设有以下说明和定义:
typedef union {long i; int k[5]; char c;} DATE;
struct data { int cat; DATE cow; double dog;} too;
DATE max;
则语句 printf("%d",sizeof(struct date)+sizeof(max));的执行结果是:_____
【标准答案】
DATE是一个union, 变量公用空间. 里面最大的变量类型是int[5], 占用20个字节. 所以它的大小是20;
data是一个struct, 每个变量分开占用空间. 依次为int4 + DATE20 +double8 = 32.
所以结果是 20 + 32 = 52.
当然...在某些16位编辑器下, int可能是2字节,那么结果是 int2 + DATE10 +
double8 = 20


以下为 Linux下的 32 位 C程序,请计算 sizeof 的值。
char str[] = “Hello” ;
char *p = str ;
int n = 10;
请计算
(1)sizeof (str ) = 6  因为编译器会给\0一个空间 strlen(str) = 5 
(2)sizeof ( p ) =  4  32位系统中地址都是32位的，因此为4个字节，不管类型是char* int *,double * ……
(3)sizeof ( n ) =  4  int类型为4个字节
【标准答案】(1)6、(2)4、(3)4


void Func ( char str[100])
{
......
;
}
请计算 sizeof( str ) = 4 ，因为数组作为函数参数时，传递的是一个地址
void *p = malloc( 100 );
请计算sizeof ( p ) =  4 ，32位系统中地址都是32位的，因此为4个字节，不管类型是char* int *,double * ……
【标准答案】4、4


int id[sizeof(unsigned long)];这个对吗?为什么?
【标准答案】正确
这个 sizeof是编译时运算符,编译时就确定了 可以看成和机器有关的常量。

#include<stdio.h>
#include<stdlib.h>
#include<string.h>

#define N 10

int main()
{
    int a[N];
    char str[6] = "hello";
    int length = sizeof(a);
    printf("length = %d\n", length);
    printf("sizeof(str) = %d\n", sizeof(str));
    printf("strlen(str) = %d\n", strlen(str));
    return 0;
}

length = 40  直接求的时候是得到数组的整个的长度
sizeof(str) = 6
strlen(str) = 5

已知一个数组table,用一个宏定义,求出数据的元素个数。
【标准答案】
#define NTBL(table) (sizeof(table)/sizeof(table[0]))

当数组作为参数传递的时候，为了使得传递的效率更高，使得传递的只是一个地址，而不是整块地址的数据







