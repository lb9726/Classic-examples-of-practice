第二部分：
2.某商品进价1200元，标价2400元。折价销售时的利润为百分之二十，问此商品是按几折销售的？
1200 × 1.2 = 2400 × X   X = 0.6

3 3 8 8不改变顺序加减乘除最后等于27怎么写啊！！！
3^3+8-8 
(3+3/8)*8
-3+38-8=27
3^3+8-8=27

一只蜗牛从井底爬到井口，……………………

用三根火柴要摆成一个最小的数 （不许把火柴折断或者弯曲),这个数是多少？
-11

第三部分
1.循环链表的主要优点是：   D
A.不再需要头指针了
B.已知某个节点的位置后，能很容易找到它的直接前驱结点
C.在进行删除操作后，能保证链表不断开
D.从表中任一结点出发都能遍历整个链表

2.下列关于一个类的静态成员的描述中，不正确的是  D 是错误的，静态数据成员变量的值是可以修改的
A. 该类的对象共享静态成员变量的值
B. 静态成员变量可被该类的所有方法访问
C. 该类的静态方法只能访问该类的静态成员变量
D. 该类的静态数据成员变量的值不可修改

3. 已知3个类O，P和Q，类O中定义了一个私有方法F1和一个公有方法F2；类P中定义了一个公有的方法F3,类P为类O的派生类；类Q为类P的派生类，它们的继承方式如下图所示：
class P:public O {……};
class Q:private P {……}; 关于类P的描述中正确的是 B
A. 类P的对象可以访问F1,但不能访问F2
B. 类P的对象可以访问F2,但不能访问F1
C. 类P的对象既可以访问F1,也可以访问F2
D. 类P的对象既不能访问F1,也不能访问F2
F2 可以访问，F1为父类的私有成员函数，子类不能继承，更不能访问

关于类Q的描述中正确的是  D
A. 类Q的对象可以访问F1,F2,F3
B. 类Q的对象可以方位F2,F3,但不能访问F1
C. 类Q的对象既可以访问F1,也可以访问F2
D. 类Q的对象既不能访问F1,F2和F3

私有继承时F3，虽然是公有方法，但是私有继承时使用类对象访问时，是不可以的;可以在类的内部访问，F1,F2由于私有继承，所以也不可以访问了

#include<iostream>
using namespace std;

class O
{
public:
	void F2()
	{
		cout << "is F2 " << endl;
	}
private:
	void F1()
	{
		cout << "is F1 " << endl;
	}
};

class P : public  O
{
public:
	void F3()
	{
		cout << "is F3" << endl;
	}
};

class Q :private  P
{
};

int main()
{
	P p;
	p.F1();
	p.F2();
	
	Q q;
	q.F1();
	q.F2();
	q.F3();
	return 0;
}

OPQ.cpp: In function ‘int main()’:
OPQ.cpp:12:7: error: ‘void O::F1()’ is private
OPQ.cpp:34:7: error: within this context
OPQ.cpp:12:7: error: ‘void O::F1()’ is private
OPQ.cpp:38:7: error: within this context
OPQ.cpp:38:7: error: ‘O’ is not an accessible base of ‘Q’
OPQ.cpp:7:7: error: ‘void O::F2()’ is inaccessible
OPQ.cpp:39:7: error: within this context
OPQ.cpp:39:7: error: ‘O’ is not an accessible base of ‘Q’
OPQ.cpp:21:7: error: ‘void P::F3()’ is inaccessible
OPQ.cpp:40:7: error: within this context
OPQ.cpp:40:7: error: ‘P’ is not an accessible base of ‘Q’


假设类C继承自类B，类B继承自类A。那么类C中的除了能够继承B类的成员函数和成员变量外，同样也能继承B类继承自A类的所有成员。换言之，类C可以继承来自类A的所有成员。因此继承既可以是直接继承，也可以是间接继承。

间接继承时的虚函数的话，最终还是能调用子类重写了的方法


4. 以下关于单件模式（singleton)的描述中，正确的是  B
A. 它描述了只有一个方法的类的集合
B. 它能够保证一个类只产生一个唯一的实例
C. 它描述了只有一个属性的类的集合
D. 它能够保证一个类的方法只能被一个唯一的类调用


5.某企业职工和部门的关系模式如下所示，其中部门负责人也是一个职工。职工和部门关系的外键分别是  B
职工(职工号，姓名，年龄，月工资，部门号，电话，办公室)
部门(部门号，部门名，负责人代号，任职时间)

A. 职工号和部门号  
B. 部门号和负责人代号
C. 职工号和负责人代号
D. 部门号和职工号

主关键字（主键）是表中的一个或多个字段，它的值用于惟一地标识表中的某一条记录。在两个表的关系中，主关键字用来在一个表中引用来自于另一个表中的特定记录。主关键字是一种唯一关键字，表定义的一部分。一个表不能有多个主关键字，并且主关键字的列不能包含空值。 
外关键字（外键）： 
如果公共关键字在一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外关键字。由此可见，外关键字表示了两个关系之间的联系。以另一个关系的外关键字作主关键字的表被称为主表，具有此外关键字的表被称为主表的从表。外关键字又称作外键。 
当一张二维表（如表A）的主关键字被包含在另一张二维表（如表B）中时，A表中的主关键字便成为B 表的外关键字。

查询每个部门中月工资更高的“职工号"的SQL的语句如下： D
Select 职工号 from 职工 as E
where 月工资=（Select Max（月工资) from 职工 as M(----))。

A.where M.职工号 = E.职工号  
B.where M.职工号 = E.负责人代码
C.where M.部门号 = 部门号
D.where M.部门号 = E.部门号


6.以下三条输出语句分别输出什么？
char str1[] = "abc";
char str2[] = "abc";
const char str3[] = "abc";
const char str4[] = "abc";
const char *str5 = "abc";
const char *str6 = "abc";

cout <<boolalpha <<(str1 == str2) <<endl;   //false
cout <<boolalpha <<(str3 == str4) << endl;  //false
cout <<boolalpha << (strt5 == str6) <<endl; //true


问答题
面向对象的三个基本特征，并简单叙述之。
封装： 将客观事物抽象成类,每个类对自身的数据和方法实行保护
继承： 广义的继承有三种实现形式:实现继承(指使用基类的属性和方法而无需额外编码的能力)、可视继承(子窗体使用父窗体的外观和实现代码)、接口继承(仅使用属性和方法,实现滞后到子类实现)。前两种(类继承)和后一种(对象组合=>接口继承以及纯虚函数)构成了功能复用的两种方式。
多态: 是将父对象设置成为和一个或更多的与他的子对象相等的技术,赋值之后,父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说,就是一句话:允许将子类类型的指针赋值给父类类型的指针。


1.分别写出Bool，int,float ,指针类型的变量a与’零‘的比较语句
bool a;
if (a) 或者 if(!a)
int a;
if (0 == a)或者 if (0 != a)
float a;
const float expersion = 0.0000001 一般情况下比之精度大于使用的编译器1到2个数量级。千万不能等于甚至小于浮点精度
if ((a >= -expersion)  && (a <= expersion))


2.描述内存分配方式以及它们的区别？

（1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。
（2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。
（3）从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。


3.阅读以下说明和C++代码，将应填入（）处的字句写在答题纸的对应栏内。
某绘图系统存在point，line，square三种图元，他们具有shape接口，图元的类图关系如图所示。现在要将circle图元加入此绘图系统以实现功能扩充。已知第三方库已经提供了XCircle类，且完全满足系统新增的Circle图元所需的功能，但XCircle有遵循Shape规则，代码4-2 根据用户制定的参数生成特定的图元实例，并对之进行显示操作。
绘图系统定义的接口与XCircle提供的显示接口及其功能如下表所示：
shape       XCircle          功能
display     Display()        显示图元

       Shape

Point   Line     Square

答案：Shape
 XCircle
 DisplayIt()
 Shape *
 getShapeInstance (type)






