#include <stdio.h>
#include<stdlib.h>

union bunion
{
    int i;
    char x[2];
}a;

int main()
{
    a.x[0] = 10;
    a.x[1] = 1;
    printf("a.i = %d\n", a.i);
    return 0;
}

/*
存储的时候是“低位在前”，a[0]是00001010，a[1]是00000001
输出的i是将二个字节作为一个整数看，即是x[1]x[0]也就是00000001 00001010
2^8+2^3+2 = 256+8+2 = 266 小端模式高字节在高位，低字节在低位

本题目设计到大端和小端模式

这里需要考虑存储模式：大端模式和小端模式。
大端模式（Big_endian）：字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中。
小端模式（Little_endian）：字数据的高字节存储在高地址中，而字数据的低字节则存放在低地址中。
union 型数据所占的空间等于其最大的成员所占的空间。对union 型的成员的存取都是相对于该联合体基地址的偏移量为0 处开始，也就是联合体的访问不论对哪个变量的存取都是从union 的首地址位置开始。如此一解释，上面的问题是否已经有了答案呢？

二、如何用程序确认当前系统的存储模式？

上述问题似乎还比较简单，那来个有技术含量的：请写一个C 函数，若处理器是Big_endian 的，则返回0；若是Little_endian 的，则返回1。

先分析一下，按照上面关于大小端模式的定义，假设int 类型变量i 被初始化为1。

以大端模式存储，其内存布局如下图：
          int i
大端模式：0x0 0x0 0x0 0x1
------------------------->高地址

小端模式：
          int i
小端模式：0x0 0x0 0x0 0x1
高地址<-----------------------

*/














